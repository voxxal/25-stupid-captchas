<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>25 stupid captchas</title>
    <link rel="icon" type="image/x-icon" href="./assets/banner-small.png">

    <meta name="title" content="25 stupid captchas" />
    <meta name="description" content="a silly game by aiden shi" />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://voxal.dev/25-stupid-captchas/" />
    <meta property="og:title" content="25 stupid captchas" />
    <meta property="og:description" content="a silly game by aiden shi" />
    <meta property="og:image" content="https://voxal.dev/25-stupid-captchas/assets/banner-large.png" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://voxal.dev/25-stupid-captchas/" />
    <meta property="twitter:title" content="25 stupid captchas" />
    <meta property="twitter:description" content="a silly game by aiden shi" />
    <meta property="twitter:image" content="https://voxal.dev/25-stupid-captchas/assets/banner-large.png" />

    <link href="style.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/@alpinejs/persist@3/dist/cdn.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/@alpinejs/sort@3/dist/cdn.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3/dist/cdn.min.js"></script>
    <script defer>
        const make4x4 = (a = "0000", b = "0000", c = "0000", d = "0000") =>
            [
                a.split("").map(x => +x),
                b.split("").map(x => +x),
                c.split("").map(x => +x),
                d.split("").map(x => +x)
            ];

        const chessBoard = () => Array(8).fill(0).map(() => Array(8).fill(0));
        const matrixMatch = (m1, m2) => {
            for (let y = 0; y < m1.length; y++) {
                for (let x = 0; x < m1[y].length; x++) {
                    if (m1[y][x] != m2[y][x] && m1[y][x] != 2) return false;
                }
            }
            return true;
        }

        function shuffle(array) {
            let currentIndex = array.length;
            while (currentIndex != 0) {
                let randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;
                [array[currentIndex], array[randomIndex]] = [
                    array[randomIndex], array[currentIndex]];
            }
        }


        const level1 = make4x4("0011", "0011", "0211", "0011")
        const level2 = make4x4()
        const level2ObjectivelyWrong = make4x4("0000", "1110", "1111", "0000")
        const level3 = "D"

        // LEVEL 4 Stuff
        const fixWiring = new Image();
        fixWiring.src = "./assets/fix-wiring.png"
        const level4Sounds = {
            open: new Audio("./assets/level4open.ogg"),
            connect: [
                new Audio("./assets/level4connect1.ogg"),
                new Audio("./assets/level4connect2.ogg"),
                new Audio("./assets/level4connect3.ogg")
            ],
            solve: new Audio("./assets/level4solve.ogg")
        }

        const level4Colors = ["#fe0000", "#2626ff", "#fdea00", "#fe00ff"]
        const level4Render = ({ state, correctWiresIn, wiresIn, wireHeld }, e = null) => {
            const canvas = document.getElementById("canvas-4");
            const ctx = canvas.getContext("2d");
            ctx.clearRect(0, 0, 400, 400);
            ctx.drawImage(fixWiring, 0, 0);
            for (let i = 0; i < 4; i++) {
                ctx.fillStyle = level4Colors[i];
                ctx.fillRect(360, 75 + i * 82, 40 - 2, 15);
                ctx.fillStyle = "#cc623d"
                ctx.fillRect(360 - 8, 75 + i * 82 + 3, 8, 9);
            }

            for (let i = 0; i < 4; i++) {
                ctx.fillStyle = level4Colors[correctWiresIn[i]];
                ctx.fillRect(3, 75 + i * 82, 40 - 2, 15);
                ctx.fillStyle = "#cc623d"
                ctx.fillRect(3 + 40 - 2, 75 + i * 82 + 3, 8, 9);
            }

            for (let i = 0; i < 4; i++) {
                if (wiresIn[i] === -1) continue;
                ctx.lineWidth = 15;
                ctx.beginPath();
                ctx.strokeStyle = level4Colors[correctWiresIn[i]]
                ctx.moveTo(40, 75 + i * 82 + 7.5)
                ctx.lineTo(360, 75 + wiresIn[i] * 82 + 7.5);
                ctx.closePath();
                ctx.stroke();
            }
            if (e != null && wireHeld != -1) {
                const rect = e.target.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                ctx.lineWidth = 15;
                ctx.beginPath();
                ctx.strokeStyle = level4Colors[correctWiresIn[wireHeld]]
                ctx.moveTo(40, 75 + wireHeld * 82 + 7.5)
                ctx.lineTo(x, y);
                ctx.closePath();
                ctx.stroke();
            }
        }

        const level4Selection = (e) => {
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            if (x > 0 && x < 65) {
                for (let i = 0; i < 4; i++) {
                    if (y > 70 + i * 82 && y < 90 + i * 82) {
                        return i;
                    }
                }
            }
            return -1;
        }

        const level4Connect = (e) => {
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            if (x > 345 && x < 400) {
                for (let i = 0; i < 4; i++) {
                    if (y > 70 + i * 82 && y < 90 + i * 82) {
                        // FIXME only fire sound if wireHeld is not -1
                        level4Sounds.connect[Math.floor(Math.random() * 3)].play();
                        return i;
                    }
                }
            }
            return -1;
        }
        const level4CheckWin = (correctWiresIn, wiresIn) => {
            for (let i = 0; i < 4; i++) {
                if (correctWiresIn[i] != wiresIn[i]) return false;
            }
            return true;
        }


        const maze = new Image();
        maze.src = "./assets/maze.png";

        const mazeEmpty = new Image();
        mazeEmpty.src = "./assets/maze-empty.png";
        let line = {};

        let prevx = -1;
        let prevy = -1;

        const level7Clear = () => {
            const canvas = document.getElementById("canvas-7");
            const ctx = canvas.getContext("2d");
            line = {};
            prevx = -1;
            prevy = -1;
            ctx.clearRect(0, 0, 400, 400);
            ctx.drawImage(maze, 0, 0);
        }

        // TODO force mouse to be on circle before starting
        const level7Draw = (e) => {
            const canvas = document.getElementById("canvas-7");
            const ctx = canvas.getContext("2d");
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            if (prevx === -1) { prevx = x }
            if (prevy === -1) { prevy = y; line = { start: [x, y], end: [x, y], valid: true } };
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.strokeStyle = "#ff0000"
            ctx.moveTo(prevx, prevy)
            ctx.lineTo(x, y);
            ctx.closePath();
            ctx.stroke();
            prevx = x;
            prevy = y;
            ctx.drawImage(mazeEmpty, 0, 0);
            if (x >= 50 && x <= 350 && y >= 50 && y <= 350) line.valid = false;
            line.end = [x, y];
        }

        const level7CheckWin = () => {
            const canvas = document.getElementById("canvas-7");
            const ctx = canvas.getContext("2d");
            const data = ctx.getImageData(0, 0, 400, 400);
            let start = null;
            if (line.valid && line.start[0] >= 185 && line.start[0] <= 199 && line.start[1] >= 32 && line.start[1] <= 46
                && line.end[0] >= 201 && line.end[0] <= 215 && line.end[1] >= 352 && line.end[1] <= 366) {
                // TODO don't wimp out on flood fill
                // actually wasnt really nessasary
                return true;
            }
            return false;
        }

        let level8State = {};
        const level8Reset = () => {
            level8State = Alpine.reactive({
                running: false,
                stack: [],
                patties: [null, null],
                held: null,
                mouse: [0, 0],
                lastTick: null,
            })
        }

        const level8Items = {
            topBun: {
                offset: [6.22, 23],
                size: [52, 17],
                drawIcon(ctx) {
                    const path = new Path2D("M51.8996 14.1724C52.2203 16 51.7967 17 50.2823 17H1.7177C0.203321 17 -0.220323 16 0.100431 14.1724C1.79668 6.25262 7.84753 0 26.0001 0C44.1526 0 50.2035 6.25262 51.8996 14.1724Z");
                    ctx.fillStyle = "#E08B4E"
                    ctx.fill(path)
                },
            },
            bottomBun: {
                offset: [6, 32],
                size: [52, 8],
                drawIcon(ctx) {
                    const path = new Path2D("M0.621268 2.48507C0.305694 1.22278 1.26041 0 2.56155 0H49.4384C50.7396 0 51.6943 1.22278 51.3787 2.48507L50.3787 6.48507C50.1561 7.37541 49.3562 8 48.4384 8H3.56155C2.64382 8 1.84385 7.37541 1.62127 6.48507L0.621268 2.48507Z")
                    ctx.fillStyle = "#E08B4E"
                    ctx.fill(path)
                }
            },
            uncookedPatty: {
                offset: [6, 29],
                size: [52, 9],
                drawIcon(ctx) {
                    ctx.beginPath();
                    ctx.roundRect(0, 0, 52, 9, 4)
                    ctx.closePath();
                    ctx.fillStyle = "#FD8A7C"
                    ctx.fill()
                }
            },
            cookedPatty: {
                ignore: true,
                offset: [6, 30],
                size: [52, 7],
                drawIcon(ctx) {
                    ctx.beginPath();
                    ctx.roundRect(0, 0, 52, 7, 4)
                    ctx.closePath();
                    ctx.fillStyle = "#662113"
                    ctx.fill()
                }
            },
            burntPatty: {
                ignore: true,
                offset: [6, 29],
                size: [52, 9],
                drawIcon(ctx) {
                    ctx.beginPath();
                    ctx.roundRect(0, 0, 52, 9, 4)
                    ctx.closePath();
                    ctx.fillStyle = "#1E1911"
                    ctx.fill()
                }
            },
            cheese: {
                offset: [18.62, 13.75],
                size: [32, 32],
                drawIcon(ctx) {
                    ctx.beginPath();
                    ctx.rotate(8.74113 * Math.PI / 180);
                    ctx.roundRect(0, 0, 32, 32, 2)
                    ctx.closePath();
                    ctx.fillStyle = "#F7C85D";
                    ctx.fill();
                },
                stackSize: [52, 2],
                drawStack(ctx) {
                    ctx.fillStyle = "#F7C85D"
                    ctx.beginPath();
                    ctx.moveTo(0, 1.5);
                    ctx.lineTo(52 / 2, 5);
                    ctx.lineTo(52, 1.5);
                    ctx.closePath();
                    ctx.fill()
                    ctx.beginPath();
                    ctx.roundRect(0, 0, 52, 3, 4);
                    ctx.closePath();
                    ctx.fill()
                }
            },
            tomato: {
                offset: [18, 15],
                size: [30, 29],
                drawIcon(ctx) {
                    const path = new Path2D("M15 5L11.1429 0L12.4286 5L6 1.66667L8.57143 5C9.78947 6.5 11.6842 7 15 7C18.3158 7 20.2105 6.5 21.4286 5L24 1.66667L17.5714 5L18.8571 0L15 5Z");
                    ctx.beginPath();
                    ctx.ellipse(15, 17, 15, 12, 0, 0, 2 * Math.PI);
                    ctx.closePath();
                    ctx.fillStyle = "#E53F34";
                    ctx.fill();
                    ctx.fillStyle = "#4A8C2B";
                    ctx.fill(path);
                },
                stackSize: [52, 4],
                drawStack(ctx) {
                    ctx.fillStyle = "#E53F34"
                    ctx.fillRect(0, 0, 52, 4);
                }
            },
            onion: {
                offset: [16, 13],
                size: [32, 35],
                drawIcon(ctx) {
                    ctx.fillStyle = "#D76D33";
                    ctx.beginPath();
                    ctx.ellipse(16, 19, 16, 16, 0, 0, 2 * Math.PI);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fill(new Path2D("M16 2C18 2 23 5 23 5H9C9 5 14 2 16 2Z"));
                    ctx.fill(new Path2D("M16 2C16.5139 2 17.2258 2.19804 18 2.49235C17.5524 2.05159 17.2336 1.04683 17.1717 0.8411C17.1642 0.815895 17.1584 0.790883 17.1523 0.765295C17.0445 0.318053 16.6437 0 16.1802 0H15.8198C15.3563 0 14.9555 0.318054 14.8477 0.765295C14.8416 0.790883 14.8358 0.815896 14.8283 0.841101C14.7664 1.04683 14.4476 2.05159 14 2.49235C14.7742 2.19804 15.4861 2 16 2Z"));
                    ctx.globalAlpha = 0.1;
                    ctx.fillStyle = "#fff";
                    for (const path of ["M16 35C16 35 18 24.9938 18 18.5C18 12.0062 16 2 16 2", "M21 35C21 35 26 25.5464 26 19C26 12.4536 21 3 21 3", "M18 35C18 35 22 25.251 22 18.5C22 11.749 18 2 18 2", "M23 35C23 35 30 25.5464 30 19C30 12.4536 23 3 23 3", "M16 35C16 35 14 24.9938 14 18.5C14 12.0062 16 2 16 2", "M11 35C11 35 6 25.5464 6 19C6 12.4536 11 3 11 3", "M14 35C14 35 10 25.251 10 18.5C10 11.749 14 2 14 2", "M9 35C9 35 2 25.5464 2 19C2 12.4536 9 3 9 3"])
                        ctx.stroke(new Path2D(path));
                    ctx.globalAlpha = 1;
                },
                stackSize: [52, 4],
                drawStack(ctx) {
                    ctx.fillStyle = "#fff"
                    ctx.fillRect(0, 0, 52, 4);
                }
            },
            lettuce: {
                offset: [6, 22],
                size: [52, 20],
                stackSize: [52, 5],
                drawIcon(ctx) {
                    const path = new Path2D("M50.8521 9.95407C48.0389 7.27301 48.2018 8.70004 46.046 8.07074C45.2273 7.83188 39.3685 0 26.0148 0H25.9852C12.6316 0 6.77277 7.83188 5.95399 8.07074C3.79822 8.70004 3.96109 7.27301 1.14792 9.95407C-0.143175 11.1851 -0.4926 11.8251 0.869565 12.1436C2.92169 12.6229 2.73514 13.9075 4.20539 14.3546C5.98508 14.8951 6.71651 13.9075 9.58594 14.3117C12.0334 14.6563 12.1933 17.9391 14.663 17.9391C17.1326 17.9391 17.1326 16.7141 19.6008 16.7141C22.069 16.7141 23.5289 20 25.9985 20C28.4682 20 29.9266 16.7141 32.3963 16.7141C34.8659 16.7141 34.8659 17.9391 37.3341 17.9391C39.8038 17.9391 39.9637 14.6563 42.4111 14.3117C45.2806 13.909 46.0135 14.8951 47.7917 14.3546C49.2619 13.9075 49.0754 12.6244 51.1275 12.1436C52.4926 11.8267 52.1447 11.1851 50.8521 9.95407Z");
                    ctx.fillStyle = "#4A8C2B";
                    ctx.fill(path);
                },
                drawStack(ctx) {
                    const path = new Path2D("M46.046 0C46.046 0 46.046 -5.16176e-05 50.8521 1.88333C52.1447 3.11438 52.4926 3.75593 51.1275 4.07288C49.0754 4.55367 49.2619 5.83678 47.7917 6.28388C46.0135 6.82438 45.2806 5.83831 42.4111 6.24101C39.9637 6.58552 39.8038 9.86832 37.3341 9.86832C34.8659 9.86832 34.8659 8.64339 32.3963 8.64339C29.9266 8.64339 28.4682 11.9293 25.9985 11.9293C23.5289 11.9293 22.069 8.64339 19.6008 8.64339C17.1326 8.64339 17.1326 9.86832 14.663 9.86832C12.1933 9.86832 12.0334 6.58552 9.58594 6.24101C6.71651 5.83678 5.98508 6.82438 4.20539 6.28388C2.73514 5.83678 2.92169 4.55214 0.869564 4.07288C-0.4926 3.7544 -0.143175 3.11438 1.14792 1.88333L5.95399 0H46.046Z");
                    ctx.fillStyle = "#4A8C2B";
                    ctx.fill(path);
                }
            }
        }

        const level8StartRender = () => {
            const canvas = document.getElementById("canvas-8");
            const ctx = canvas.getContext("2d");

            if (level8State.running) return;
            const loop = (ts) => {
                if (!level8State.lastTick) level8State.lastTick = ts;
                const dt = (ts - level8State.lastTick) / 1000;
                if (!level8State.running) return;
                ctx.fillStyle = "white"

                ctx.clearRect(0, 0, 400, 400);
                // TOP BAR
                ctx.fillStyle = "black";
                ctx.fillRect(0, 0, 400, 32);
                {
                    ctx.save();
                    for (const [k, item] of Object.entries(level8Items)) {
                        if (item.ignore) continue;
                        ctx.save();
                        ctx.scale(0.5, 0.5)
                        ctx.translate(...item.offset);
                        item.drawIcon(ctx);
                        ctx.restore();
                        ctx.translate(36, 0);
                    }
                    ctx.restore();
                }
                // PATTY COOKING
                ctx.fillStyle = "#555";
                ctx.fillRect(0, 36, 198, 400 - 36);
                ctx.fillStyle = "black";
                ctx.beginPath()
                ctx.arc(100, 36 + 96, 64, 0, 2 * Math.PI);
                ctx.closePath()
                ctx.fill();
                ctx.strokeStyle = "#555";
                ctx.beginPath()
                ctx.arc(100, 36 + 96, 48, 0, 2 * Math.PI);
                ctx.closePath()
                ctx.stroke();
                ctx.beginPath()
                ctx.arc(100, 36 + 96, 32, 0, 2 * Math.PI);
                ctx.closePath()
                ctx.stroke();
                if (level8State.patties[0]) {
                    level8State.patties[0] -= dt;
                    if (level8State.patties[0] > 0) {
                        ctx.fillStyle = "#FD8A7C";
                    } else if (level8State.patties[0] > -10) {
                        ctx.fillStyle = "#662113";
                    } else {
                        ctx.fillStyle = "#1E1911";
                    }
                    ctx.beginPath()
                    ctx.arc(100, 36 + 96, 48, 0, 2 * Math.PI)
                    ctx.closePath()
                    ctx.fill();
                }
                ctx.fillStyle = "black";
                ctx.beginPath()
                ctx.arc(100, 400 - 96, 64, 0, 2 * Math.PI);
                ctx.closePath()
                ctx.fill();
                ctx.strokeStyle = "#555";
                ctx.beginPath()
                ctx.arc(100, 400 - 96, 48, 0, 2 * Math.PI);
                ctx.closePath()
                ctx.stroke();
                ctx.beginPath()
                ctx.arc(100, 400 - 96, 32, 0, 2 * Math.PI);
                ctx.closePath()
                ctx.stroke();
                if (level8State.patties[1]) {
                    level8State.patties[1] -= dt;
                    if (level8State.patties[1] > 0) {
                        ctx.fillStyle = "#FD8A7C";
                    } else if (level8State.patties[1] > -10) {
                        ctx.fillStyle = "#662113";
                    } else {
                        ctx.fillStyle = "#1E1911";
                    }
                    ctx.beginPath()
                    ctx.arc(100, 400 - 96, 48, 0, 2 * Math.PI)
                    ctx.closePath()
                    ctx.fill();
                }


                // STACK
                ctx.fillStyle = "#B2FFFF";
                ctx.fillRect(202, 36, 198, 400 - 36);
                ctx.fillStyle = "#966F33";
                ctx.fillRect(202, 400 - 36, 198, 36);
                let height = 400 - 36;

                for (const itemId of level8State.stack) {
                    const item = level8Items[itemId];
                    const size = item?.stackSize ?? item.size;
                    ctx.save();
                    height -= size[1] * 2
                    ctx.translate(202, height);
                    ctx.translate(size[0], 0);
                    ctx.scale(2, 2);
                    item?.drawStack ? item.drawStack(ctx) : item.drawIcon(ctx);
                    ctx.restore();
                }

                if (level8State.held != null) {
                    const item = level8Items[level8State.held];
                    ctx.save();
                    ctx.translate(...level8State.mouse);
                    ctx.translate(-item.size[0], -item.size[1])
                    ctx.scale(2, 2);
                    item.drawIcon(ctx);
                    ctx.restore();
                }
                level8State.lastTick = ts;
                requestAnimationFrame(loop);
            }
            level8State.running = true;
            requestAnimationFrame(loop);
        }

        const level8MouseDown = (e) => {
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            if (y > 0 && y < 40) {
                let i = 0;
                for (const [k, item] of Object.entries(level8Items)) {
                    if (item.ignore) continue;
                    if (x > i * 36 && x < (i + 1) * 36) {
                        level8State.held = k;
                        return k;
                    }
                    i++;
                }
            }
            // ctx.arc(100, 36 + 96, 64, 0, 2 * Math.PI);
            if (Math.hypot(x - 100, y - (36 + 96)) < 64 && level8State.patties[0]) {
                level8State.held = level8State.patties[0] > 0 ? "uncookedPatty" : level8State.patties[0] > -10 ? "cookedPatty" : "burntPatty";
                level8State.patties[0] = null;
                return level8State.held;
            }

            if (Math.hypot(x - 100, y - (400 - 96)) < 64 && level8State.patties[1]) {
                level8State.held = level8State.patties[1] > 0 ? "uncookedPatty" : level8State.patties[1] > -10 ? "cookedPatty" : "burntPatty";
                level8State.patties[1] = null;
                return level8State.held;
            }
            level8State.held = null;
            return null;
        }

        const level8MouseUp = (e) => {
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            if (level8State.held === "uncookedPatty" && x <= 198 && y >= 36) {
                const slot = +(y >= 200)
                level8State.patties[slot] = 10
            }
            if (level8State.held && x >= 202 && y >= 36) {
                level8State.stack.push(level8State.held);
                level8State.held = null;
                return true;
            }
            level8State.held = null;
        }

        const level8MouseMove = (e) => {
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            level8State.mouse = [x, y];
        }

        const level8Validate = () => {
            const stack = level8State.stack;
            level8State.stack = [];
            const validWrapping =
                // bun wrap
                (stack[0] === "bottomBun" && stack[stack.length - 1] === "topBun") ||
                // lettuce wrap
                (stack[0] === stack[stack.length - 1] === "lettuce");
            if (!validWrapping) return "wrong";
            let foundPatty = false;
            for (let i = 1; i < stack.length - 1; i++) {
                if (["uncookedPatty", "burntPatty", "topBun"].includes(stack[i])) return "wrong";
                if (stack[i - 1] !== "cookedPatty" && stack[i] === "cheese" && stack[i + 1] === "cookedPatty") return "wrong";
                if (stack[i] === "cookedPatty") foundPatty = true;
            }
            return foundPatty ? "solved" : "wrong";
        }

        const level9Cells = [
            [2, 0, 1, 0],
            [0, 0, 3, 0],
            [3, 0, 0, 0],
            [0, 1, 0, 1],
        ]

        const level9 = make4x4("0000", "1100", "0101", "0000");
        const level10Init = (json) => {
            for (const i in json.categories) {
                const category = json.categories[i];
                for (const { position, content } of category.cards) {
                    level10Cells[Math.floor(position / 4)][position % 4] = content;
                }

                if (i === "3") {
                    for (const { position } of category.cards) {
                        level10[Math.floor(position / 4)][position % 4] = 1;
                    }
                }
            }
        }

        let level10Cells = null;
        let level10 = Array(4).fill(0).map(() => Array(4).fill(0));
        const level11 = "bDKlrDS";

        let level13State = {};
        const level13Reset = () => {
            level13State = Alpine.reactive({
                timer: 0,
                running: false,
                lastTick: null,
                score: 0,
                x: 0,
                y: 200,
                vel: 0,
                pipes: [{ x: 200, gap: 200, scored: false }],
                state: "waiting",
            })
        }

        const level13Assets = {
            robot: new Image(),
            floor: new Image(),
            pipe: new Image(),
        }
        level13Assets.robot.src = "./assets/robot.png";
        level13Assets.floor.src = "./assets/floor.png";
        level13Assets.pipe.src = "./assets/captcha.png";
        const LEVEL13_GAP_SIZE = 150;

        const level13StartRender = (data) => {
            const canvas = document.getElementById("canvas-13");
            const ctx = canvas.getContext("2d");

            if (level13State.running) return;
            const loop = (ts) => {
                if (!level13State.lastTick) level13State.lastTick = ts;
                const dt = (ts - level13State.lastTick) / 1000;
                if (!level13State.running) return level13State.lastTick = null;
                level13State.timer += dt;
                const { x, y } = level13State;
                // gravity and vel
                if (level13State.state === "playing") {
                    level13State.vel += 200 * dt;
                    level13State.y += level13State.vel * dt;
                    level13State.x += 50 * dt;
                    if (y > 400 - 64 - 20) {
                        level13State.state = "dead";
                        level13CheckWin(data);
                    };
                    for (const pipe of level13State.pipes) {
                        if (x + 20 > pipe.x - 40.5 && x - 20 < pipe.x + 40.5 && (y - 20 < pipe.gap - LEVEL13_GAP_SIZE / 2 || y + 20 > pipe.gap + LEVEL13_GAP_SIZE / 2)) {
                            level13State.state = "dead";
                            level13CheckWin(data);
                        }
                        if (!pipe.scored && x - 20 > pipe.x + 40.5) {
                            pipe.scored = true;
                            level13State.score += 1;
                        }
                    }

                    if (level13State.timer >= 3.5) {
                        level13State.timer -= 3.5;
                        level13State.pipes.push({ x: x + 240.5, gap: Math.floor(Math.random() * 200) + LEVEL13_GAP_SIZE / 2 })
                    }

                }
                ctx.clearRect(0, 0, 400, 400);
                ctx.fillStyle = "#B2FFFF"
                ctx.fillRect(0, 0, 400, 400);
                for (const pipe of level13State.pipes) {
                    ctx.drawImage(level13Assets.pipe, pipe.x - x + 200 - 40.5, pipe.gap - LEVEL13_GAP_SIZE / 2 - 327, 81, 327);
                    ctx.drawImage(level13Assets.pipe, pipe.x - x + 200 - 40.5, pipe.gap + LEVEL13_GAP_SIZE / 2, 81, 327);
                }
                const textureOffset = -x;
                for (let tx = (x - 200) - ((x - 200) % 140); tx < x + 400; tx += 140) {
                    ctx.drawImage(level13Assets.floor, tx + textureOffset, 400 - 64, 140, 64);
                }
                ctx.drawImage(level13Assets.robot, 200 - 20, y - 20, 40, 40);
                if (level13State.state === "playing") {
                    ctx.font = "48px Helvetica, sans-serif";
                    let text = ctx.measureText(level13State.score);
                    ctx.fillStyle = "black"
                    ctx.fillText(level13State.score, 200 - text.width / 2, 50);

                } else if (level13State.state === "waiting") {
                    ctx.font = "48px Helvetica, sans-serif";
                    let text = ctx.measureText("Click to start");
                    ctx.fillStyle = "black"
                    ctx.fillText("Click to start", 200 - text.width / 2, 50);
                } else if (level13State.state === "dead") {
                    ctx.font = "48px Helvetica, sans-serif";
                    let text = ctx.measureText("You Died");
                    ctx.fillStyle = "black"
                    ctx.fillText("You Died", 200 - text.width / 2, 50);
                } else if (level13State.state === "won") {
                    ctx.font = "48px Helvetica, sans-serif";
                    let text = ctx.measureText("You Won!");
                    ctx.fillStyle = "black"
                    ctx.fillText("You Won!", 200 - text.width / 2, 50);
                }

                level13State.lastTick = ts;
                requestAnimationFrame(loop);
            }
            level13State.running = true;
            requestAnimationFrame(loop);
        }
        const level13CheckWin = (data) => {
            if (level13State.score >= 10) { setTimeout(() => { data.solve(); level13State.running = false }, 750); level13State.state = "won" }
            else data.state = "wrong";
        }

        const level13MouseDown = () => {
            if (level13State.state === "dead") {
                level13Reset();
                level13State.running = true;
                return;
            }
            if (level13State.state === "waiting") level13State.state = "playing";
            level13State.vel = -110;
        }

        const level14 = make4x4("0011", "0011", "1000", "1000")
        const level14AdClick = (e) => {
            e.preventDefault();
            const gtec = open("ghostector.html");
            gtec.postMessage("init");
        }

        let bossGhost = null;
        let lazerOpacity = 0;
        const ghosts = [
            { anchor: "ghost-grid", offset: [0, 0], image: new Image(), size: [95, 95 * 2], opacity: 0.5 },
            { anchor: "ghost-grid", offset: [95 * 2, 95 * 2], image: new Image(), size: [95 * 2, 95 * 2], opacity: 0.5 },
            // His name is Edward
            { anchor: "jumpy-button", offset: [-70, -100], image: new Image(), size: [256, 256], opacity: 0.9 },
            { anchor: "boss-ghost-anchor", offset: [-9999, -9999], image: new Image(), size: [300, 400], opacity: 1, alwaysShow: true },
        ]
        ghosts[0].image.src = "./assets/ghosts/happy-ghost.png";
        ghosts[1].image.src = "./assets/ghosts/gang-ghost.png";
        ghosts[2].image.src = "./assets/ghosts/troll-ghost.png";
        ghosts[3].image.src = "./assets/ghosts/boss-ghost.png";
        const crosshair = new Image();
        crosshair.src = "./assets/ghostector-crosshair.svg";
        const ghostectorRender = (data) => {
            let lastTick = null;
            const canvas = document.getElementById("ghostector-canvas");
            const ctx = canvas.getContext("2d");
            const loop = (ts) => {
                if (!lastTick) lastTick = ts;
                const dt = (ts - lastTick) / 1000;
                lazerOpacity -= dt;

                const ghostectorPos = Alpine.store("game").ghostectorPos;
                // const { ghostectorPos } = data;
                ctx.clearRect(0, 0, 192, 192);
                ctx.fillStyle = "#B2FFFF"
                for (const ghost of ghosts) {
                    if (typeof ghost.anchor === "string") {
                        ghost.anchor = document.getElementById(ghost.anchor);
                    }

                    if (ghost.anchor.offsetParent || ghost.alwaysShow) {
                        const bb = ghost.anchor.getBoundingClientRect();
                        ctx.globalAlpha = ghost.opacity;
                        ctx.drawImage(ghost.image, bb.x - ghostectorPos[0] + ghost.offset[0], bb.y - ghostectorPos[1] + ghost.offset[1], ...ghost.size)
                    }
                }

                if (lazerOpacity > 0) {
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = "#f00";
                    ctx.globalAlpha = lazerOpacity;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(196, 196);
                    ctx.moveTo(0, 196);
                    ctx.lineTo(196, 0);
                    ctx.stroke();
                }

                if (Alpine.store("game").upgrades[3].inPlace || Alpine.store("game").upgradesSlotted) {
                    // { id: "ghostector-crosshair", anchor: [0 * 2, 31 * 2], size: [65 * 2, 33 * 2] },
                    ctx.globalAlpha = 1;
                    ctx.drawImage(crosshair, 0 * 2, 31 * 2, 65 * 2, 33 * 2);
                }

                lastTick = ts;
                requestAnimationFrame(loop);
            }
            requestAnimationFrame(loop);
        }

        const level15 = make4x4("1101", "1001", "0110", "0100");

        const level17 = make4x4("1020", "2120", "0201", "0222");
        const level18 = [
            [0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 0, 1, 1, 0, 0],
            [0, 0, 0, 1, 2, 1, 1, 1],
            [0, 0, 0, 1, 0, 0, 0, 0],
            [0, 0, 1, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0],
        ];

        let level19State = {};
        const level19CreateBarrel = (x) => {
            const order = ["curlingStone", "hongbao", "seven"]
            shuffle(order)
            return {
                x,
                vel: 0,
                sides: [
                    { pos: -25, img: order[0] },
                    { pos: 125, img: order[1] },
                    { pos: 275, img: order[2] },
                    { pos: 425, img: order[0] },
                    { pos: 575, img: order[1] },
                    { pos: 725, img: order[2] }
                ],
                spinning: false,
                selected: null,
                toMove: null,
            }
        }
        const level19Reset = () => {
            level19State = Alpine.reactive({
                running: false,
                lastTick: null,
                barrels: [level19CreateBarrel(10), level19CreateBarrel(3 / 4 * 150 + 30), level19CreateBarrel(3 / 4 * 150 * 2 + 50)],
                spinning: false,
            })
        }

        const level19Assets = {
            curlingStone: new Image(),
            hongbao: new Image(),
            seven: new Image(),
        }
        level19Assets.curlingStone.src = "./assets/level19/curlingStone.jpg";
        level19Assets.hongbao.src = "./assets/level19/hongbao.png";
        level19Assets.seven.src = "./assets/level19/seven.jpg";

        const level19StartRender = (data) => {
            const canvas = document.getElementById("canvas-19");
            const ctx = canvas.getContext("2d");

            if (level19State.running) return;
            const loop = (ts) => {
                if (!level19State.lastTick) level19State.lastTick = ts;
                const dt = (ts - level19State.lastTick) / 1000;
                if (!level19State.running) return level19State.lastTick = null;

                const wasSpinning = level19State.spinning;
                level19State.spinning = level19State.barrels.some(barrel => barrel.vel > 0);
                if (wasSpinning && !level19State.spinning) {
                    level19CheckWin(data);
                }

                for (const barrel of level19State.barrels) {
                    barrel.vel = Math.max(0, barrel.vel - 25 * dt);
                    let sideSnap = 0;
                    if (barrel.toMove) {
                        sideSnap = Math.min(Math.abs(barrel.toMove * 5 * dt), 5) * Math.sign(barrel.toMove)
                        barrel.toMove = barrel.toMove - sideSnap
                        if (barrel.toMove === 0) barrel.toMove = nil
                    }

                    for (const side of barrel.sides) {
                        side.pos += barrel.vel + sideSnap
                    }

                    if (barrel.vel === 0 && barrel.spinning) {
                        barrel.spinning = false;
                        const targetCenter = 400 / 2 - 75;
                        let closest = 0;
                        let closestBy = Math.abs(targetCenter - barrel.sides[0].pos);
                        for (let i = 0; i < barrel.sides.length; i++) {
                            const side = barrel.sides[i];
                            if (Math.abs(targetCenter - side.pos) < closestBy) {
                                closest = i;
                                closestBy = Math.abs(targetCenter - side.pos)
                            }
                        }

                        let toMove = (400 / 2 - 75) - barrel.sides[closest].pos
                        barrel.selected = barrel.sides[closest]
                        barrel.toMove = toMove;
                    }

                    for (const side of barrel.sides) {
                        let cutoff = 150 * barrel.sides.length - 150
                        if (side.pos > cutoff) side.pos = -150 + (side.pos - cutoff)
                    }
                }

                // DRAW
                ctx.clearRect(0, 0, 400, 400);
                ctx.fillStyle = "rgb(218, 165, 32)"
                ctx.fillRect(0, 0, 400, 400);
                for (const barrel of level19State.barrels) {
                    ctx.fillStyle = "#fff"
                    ctx.fillRect(barrel.x, 0, 3 / 4 * 150, 400);
                    for (const side of barrel.sides) {
                        ctx.drawImage(level19Assets[side.img], barrel.x, side.pos, 3 / 4 * 150, 150)
                    }
                }
                level19State.lastTick = ts;
                requestAnimationFrame(loop);
            }
            level19State.running = true;
            requestAnimationFrame(loop);
        }

        const level19CheckWin = (data) => {
            if (level19State.barrels.every(({ selected: { img } }) => img === level19State.barrels[0].selected.img)) {
                // TODO add casino sound
                Alpine.store('game').money += 5;
                setTimeout(() => {
                    data.solve();
                }, 500)
            }
        }

        const level19Spin = (data) => {
            if (!level19State.spinning) {
                if (Alpine.store('game').money < 0.5) return data.state = "poor";
                Alpine.store('game').money -= 0.5;
                let spin = 80

                for (const barrel of level19State.barrels) {
                    barrel.spinning = true;
                }

                spin += Math.random() * 50;
                level19State.barrels[0].vel = spin;
                spin += Math.random() * 30;
                level19State.barrels[1].vel = spin;
                spin += Math.random() * 20;
                level19State.barrels[2].vel = spin;
            }
        }

        const level20Clear = () => {
            const canvas = document.getElementById("canvas-20");
            const ctx = canvas.getContext("2d");
            ctx.clearRect(0, 0, 400, 400);
            ctx.fillStyle = "#7999a8";
            ctx.fillRect(0, 0, 400, 400);
            level20Lines(ctx);
        }

        const level20Lines = (ctx) => {
            ctx.fillStyle = "#fff";
            for (let i = 100; i < 400; i += 100) {
                ctx.fillRect(i, 0, 2, 400);
            }
            for (let i = 100; i < 400; i += 100) {
                ctx.fillRect(0, i, 400, 2);
            }
        }

        const level20Draw = (e) => {
            const canvas = document.getElementById("canvas-20");
            const ctx = canvas.getContext("2d");
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            ctx.lineWidth = 32;
            ctx.beginPath();
            ctx.fillStyle = "#94c8e0"
            ctx.arc(x, y, 24, 0, 2 * Math.PI)
            ctx.closePath();
            ctx.fill();
            level20Lines(ctx);
        }

        const level20CheckWin = () => {
            const canvas = document.getElementById("canvas-20");
            const ctx = canvas.getContext("2d");
            const data = ctx.getImageData(0, 0, 400, 400).data;
            let count = 0;
            for (let i = 0; i < data.length; i += 4) {
                count += data[i] === 0x94;
            }
            return count > 370 * 370;
        }

        const spawnUpgrades = () => {
            const game = Alpine.store("game");
            if (game.upgradesShown || game.upgradesSlotted) return;
            let { top, left } = document.getElementById("upgrade-spawn").getBoundingClientRect();
            left += 100;
            game.upgrades[0].pos = [left + 40, top];
            game.upgrades[1].pos = [left + 94, top + 12];
            game.upgrades[2].pos = [left + 120, top];
            game.upgrades[3].pos = [left + 120, top + 40];

            game.upgradesShown = true;
        }

        const updateUpgradePos = (game) => {
            for (const upgrade of game.upgrades) {
                const pos = game.upgrades.find(({ id }) => id === upgrade.parent)?.pos ?? game.ghostectorPos;
                if (upgrade.inPlace || game.upgradesSlotted) upgrade.pos = [pos[0] + upgrade.anchor[0], pos[1] + upgrade.anchor[1]];
            }
        }

        const gtScreenState = {
            bg: null,
            pos: 4,
            dragged: false,
            correct: 70,
        };
        const gtScreenBgs = [new Image(), new Image(), new Image(), new Image()];
        // Me no like factory image.
        gtScreenBgs[0].src = "./assets/jigsaws/factory.png";
        gtScreenBgs[1].src = "./assets/jigsaws/dev.png";
        gtScreenBgs[2].src = "./assets/jigsaws/grass.png";
        gtScreenBgs[3].src = "./assets/jigsaws/ghost.png";
        const gtScreenJigsaw = new Path2D("M29.6586 8C29.8797 7.37444 30 6.70127 30 6C30 2.68629 27.3137 0 24 0C20.6863 0 18 2.68629 18 6C18 6.70127 18.1203 7.37444 18.3414 8H9C8.44771 8 8 8.44771 8 9V18.3414C7.37444 18.1203 6.70127 18 6 18C2.68629 18 0 20.6863 0 24C0 27.3137 2.68629 30 6 30C6.70127 30 7.37444 29.8797 8 29.6586V39C8 39.5523 8.44771 40 9 40H18.3414C18.1203 40.6256 18 41.2987 18 42C18 45.3137 20.6863 48 24 48C27.3137 48 30 45.3137 30 42C30 41.2987 29.8797 40.6256 29.6586 40H39C39.5523 40 40 39.5523 40 39V31.0727C40 30.3825 39.3101 29.8971 38.6236 29.968C38.4186 29.9892 38.2106 30 38 30C34.6863 30 32 27.3137 32 24C32 20.6863 34.6863 18 38 18C38.2106 18 38.4186 18.0108 38.6236 18.032C39.3101 18.1029 40 17.6175 40 16.9273V9C40 8.44771 39.5523 8 39 8H29.6586Z")

        const gtScreenReset = () => {
            const canvas = document.getElementById("ghostector-screen-canvas");
            const ctx = canvas.getContext("2d");
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, canvas.width, 20);
        }

        const gtScreenNew = () => {
            gtScreenState.bg = Math.floor(Math.random() * gtScreenBgs.length);
            gtScreenState.pos = 4;
            gtScreenState.correct = Math.floor(Math.random() * 70) + 30
            gtScreenDraw();
        }

        const gtScreenMouseDown = (e) => {
            const rect = e.target.getBoundingClientRect();
            const x = e.clientX - rect.left;
            gtScreenState.dragged = x > gtScreenState.pos && x <= gtScreenState.pos + 20;
        }

        const gtScreenMouseUp = (e) => {
            if (Math.abs(gtScreenState.correct - gtScreenState.pos) < 5) {
                lazerOpacity = 1;
                // FIREEEEEE
                const fireCenter = Alpine.store("game").ghostectorPos.map(x => x + 192 / 2);
                if (fireCenter[0] >= ghosts[3].offset[0] && fireCenter[0] <= ghosts[3].offset[0] + ghosts[3].size[0] &&
                    fireCenter[1] >= ghosts[3].offset[1] && fireCenter[1] <= ghosts[3].offset[1] + ghosts[3].size[1] && clickedOnGhost()) {
                    bossGhost.hp -= 1;
                    fadeOut();
                }

                gtScreenNew();
            }
            gtScreenState.dragged = false;
        }

        const gtScreenDraw = () => {
            const canvas = document.getElementById("ghostector-screen-canvas");
            const ctx = canvas.getContext("2d");
            const img = gtScreenBgs[gtScreenState.bg];
            ctx.drawImage(img, 0, 0);
            // ctx.fillRect(0, 0, canvas.width, 20);
            ctx.save();
            ctx.fillStyle = "#fff"
            ctx.fillRect(0, 0, 20, 20);


            ctx.save();
            ctx.fillStyle = "#555";
            ctx.translate(gtScreenState.correct, 3);
            ctx.scale(1 / 3, 1 / 3);
            ctx.fill(gtScreenJigsaw);
            ctx.restore();

            ctx.save();
            ctx.translate(gtScreenState.pos, 3);
            ctx.scale(1 / 3, 1 / 3);

            ctx.save();
            ctx.shadowColor = "#000";
            ctx.shadowBlur = 3;
            ctx.fill(gtScreenJigsaw);
            ctx.restore();

            ctx.clip(gtScreenJigsaw);
            ctx.scale(3, 3);
            ctx.translate(-gtScreenState.correct, 0);
            ctx.drawImage(img, 0, 0);
            ctx.restore();

            ctx.restore();
        }

        const gtScreenMouseMove = (e) => {
            if (!Alpine.store('game').upgradesSlotted) return;
            const rect = e.target.getBoundingClientRect();
            if (gtScreenState.dragged) {
                const x = e.clientX - rect.left;
                gtScreenState.pos = x - 10;
            }
            gtScreenDraw();
        }


        const fadeOut = () => {
            let opacity = 1;
            let lastTick = null;
            let req = null;
            const loop = (ts) => {
                if (!lastTick) lastTick = ts;
                const dt = (ts - lastTick) / 1000;
                opacity -= dt;
                ghosts[3].opacity = opacity;
                if (opacity <= 0) {
                    ghosts[3].size = [300, 400].map(x => x * (bossGhost.hp + 4) / 10);
                    ghosts[3].offset = [Math.floor(Math.random() * (window.innerWidth - 300)), Math.floor(Math.random() * (window.innerHeight - 400))];
                    if (bossGhost.hp <= 0) {
                        ghosts[3].offset = [-999, -999];
                        bossGhost.hp = 6;
                        ghosts[3].size = [300, 400];
                        ghosts[3].offset = [-999, -999], 
                        playDefeatAnimation();
                        cancelAnimationFrame(req);
                        return;
                    }
                    ghosts[3].opacity = 1;
                    return;
                }
                lastTick = ts;
                req = requestAnimationFrame(loop);
            }
            req = requestAnimationFrame(loop);
        }
        const clickedOnGhost = () => {
            const data = document.getElementById("ghostector-canvas").getContext("2d").getImageData(192 / 2, 192 / 2, 2, 2);
            for (let i = 0; i < 4; i++) {
                if (data.data[i * 4 + 3] === 255) return true;
            }
            return false;
        }

        const playDefeatAnimation = () => {
            document.getElementById("victory-message").style.display = "grid";
            document.getElementById("victory-message").classList.add("victory-message-animation");
            document.getElementById("echo").classList.add("echo-animation");

            setTimeout(() => {
                document.getElementById("victory-message").classList.remove("victory-message-animation");
                document.getElementById("echo").classList.remove("echo-animation");
                document.getElementById("victory-message").style.display = "none";
            }, 5500);
        }

        const level22Text = `function getGhostRecords() {
  fetch("https://gtinc.com/ghostrecords")
    .then(x=>x.json()).then(getThreats);
}
function getThreats(ghosts) {
  const threats = [];
  for (const ghost of ghosts) {
    if (ghost.powerLevel > 9001) {
      threats.push(ghost);
    } else if (ghost.confirmedKills > 300) {
      threats.push(ghost);
    } else if (ghost.roboticness > 0.4) {
      threats.push(ghost);
    }
  }
  console.log("THREATS FOUND");
  console.log(threats);
  return threats;
}`

        const spawnBoss = () => {
            const game = Alpine.store("game");
            if (game.bossSpawned) return;
            let { top, left } = document.getElementById("boss-spawn").getBoundingClientRect();
            left += 100;
            ghosts[3].offset = [left, top - 150];

            game.bossSpawned = true;
        }

        let level24Running = false;

        const level24Start = (data) => {
            if (level24Running) return;
            let lastTick = 0;
            const loop = (ts) => {
                if (lastTick === 0) lastTick = ts;
                const dt = (ts - lastTick) / 1000;
                if (!level24Running) return;

                const growth = data.frustrated ? 0.1 * dt : 0.05 * Math.pow(1 - Math.sqrt(data.progress), 2) * dt
                data.progress = Math.min(1, data.progress + growth);
                if (data.progress === 1) {
                    setTimeout(() => {
                        data.state = 'solved';
                        Alpine.store('game').solve(24);
                        data.progress = 0;
                    }, 500);
                    return;
                }

                lastTick = ts;
                requestAnimationFrame(loop);
            }
            level24Running = true;
            requestAnimationFrame(loop);
        }
        let level25Connected = false;
        const youveGotMail = new Audio("./assets/youve-got-mail-sound.mp3");
        const WS_URL = "wss://stupid-captchas-server.fly.dev/"
        const level25Connect = (data) => {
            if (level25Connected) return;
            data.ws = new WebSocket(WS_URL + data.room);
            data.ws.onmessage = (e) => {
                const msg = JSON.parse(e.data);
                if (msg.type === "human") {
                    Alpine.store('game').solve(25);
                    data.human = true;
                } else if (msg.type === "get") {
                    data.msgs = msg.msgs;
                    data.room = msg.room;
                } else if (msg.type === "msg") {
                    data.msgs = [...data.msgs, msg.msg];

                    const msgs = document.getElementById('msgs');
                    const scrollableDistance = msgs.scrollHeight - msgs.offsetHeight;
                    data.autoscroll = msgs.scrollTop > scrollableDistance - 20;

                    if (!document.hasFocus()) {
                        youveGotMail.play();
                    }
                }
            }

            data.ws.onclose = (e) => {
                console.log('Socket is closed. Reconnect will be attempted in 1 second.', e.reason);
                level25Connected = false;
                setTimeout(() => {
                    document.removeEventListener("keypress", handler);
                    level25Connect();
                }, 1000);
            };

            const handler = (e) => {
                if (e.key === "Enter" && data.state === 'open') level25Send(data);
            };

            document.addEventListener("keypress", handler);
            level25Connected = true;
        }

        const level25Send = (data) => {
            if (!data.ws) return alert('failed to send message try again later :(');
            data.ws.send(JSON.stringify({ type: "msg", msg: data.message }));
            data.message = '';
        }

        const isOverflown = ({ clientWidth, clientHeight, scrollWidth, scrollHeight }) => {
            return scrollHeight > clientHeight;
        }

        const eitherOr = (s1, s2) => s1 === "solved" || s2 === "solved" ? "solved" : "wrong";
        document.addEventListener('alpine:init', () => {
            level8Reset();
            level10Cells = Alpine.reactive(Array(4).fill(0).map(() => Array(4).fill(null)));
            // https://stackoverflow.com/a/62827809
            const date = new Date().toLocaleDateString('pt-br').split('/').reverse().join('-');
            fetch('https://corsproxy.io/?' + encodeURIComponent(`https://www.nytimes.com/svc/connections/v2/${date}.json`))
                .then(res => res.json())
                .then(level10Init);
            level13Reset();
            level19Reset();
            bossGhost = Alpine.reactive({ hp: 6 })
            window.addEventListener("message", (e) => {
                if (e.data === "attemptBuy") {
                    if (Alpine.store("game").boughtGhostector) {
                        e.source.postMessage("alreadyBought");
                    } else if (Alpine.store("game").money >= 20) {
                        e.source.postMessage("success");
                        Alpine.store("game").boughtGhostector = true;
                        Alpine.store("game").money -= 20;
                    } else {
                        e.source.postMessage("tooPoor");
                    }
                }
            })
            Alpine.store('game', {
                started: Alpine.$persist(false),
                startedDots: 0,
                level: Alpine.$persist(0),
                money: Alpine.$persist(0),
                boughtGhostector: Alpine.$persist(false),
                ghostectorPos: Alpine.$persist([16, 16]),
                upgradesShown: false,
                upgradesSlotted: Alpine.$persist(false),
                upgrades: [
                    { id: "ghostector-battery-slot", anchor: [90 * 2, 20 * 2], size: [22 * 2, 56 * 2] },
                    { id: "ghostector-battery", anchor: [10 * 2, 7 * 2], parent: "ghostector-battery-slot", size: [8 * 2, 42 * 2], z: 10000 },
                    { id: "ghostector-screen", anchor: [21 * 2, -11 * 2], size: [56 * 2, 17 * 2] },
                    { id: "ghostector-crosshair", anchor: [0 * 2, 31 * 2], size: [65 * 2, 33 * 2] },
                ],
                bossSpawned: false,

                startGame() {
                    if (this.started) return;
                    this.started = true;
                    for (let i = 0; i <= 2; i++) {
                        setTimeout(() => {
                            this.startedDots += 1;
                        }, i * 1000);
                    }
                    setTimeout(() => {
                        this.level = 1;
                    }, 3000);
                },
                solve(level) {
                    this.level = Math.max(level + 1, this.level);
                    return "solved"
                },
                solveMat(level, correct, user) {
                    if (matrixMatch(correct, user)) {
                        this.level = Math.max(level + 1, this.level);
                        return "solved"
                    }
                    return "wrong"
                },
                solveGridCount(level, count, user) {
                    if (user.flat().reduce((acc, v) => acc + v, 0) >= count) {
                        this.level = Math.max(level + 1, this.level);
                        return "solved"
                    }
                    return "wrong"
                },
                solveEq(level, correct, user) {
                    if (correct === user) {
                        this.level = Math.max(level + 1, this.level);
                        return "solved"
                    }
                    return "wrong"
                },
                gtMouseDown(e) {
                    const rect = e.target.getBoundingClientRect();
                    this.ghostectorHeld = [e.clientX - rect.left, e.clientY - rect.top];
                },
                gtMove(e) {
                    if (this.ghostectorHeld)
                        this.ghostectorPos = [e.clientX - this.ghostectorHeld[0], e.clientY - this.ghostectorHeld[1]]
                }
            })
            Alpine.bind("ghostectorUpgrade", () => ({
                class: 'ghostector-upgrade',
                "x-show"() { return this.$store.game.upgradesShown || this.$store.game.upgradesSlotted },
                "x-init"() {
                    const upgrade = this.$store.game.upgrades[this.i];
                    upgrade.held = null;
                    upgrade.pos = [0, 0];
                    upgrade.inPlace = false;
                    const handler = (e) => {
                        if (!(this.$store.game.upgradesShown || this.$store.game.upgradesSlotted)) return;
                        if (this.$store.game.upgrades.every(u => u.inPlace && !u.held) || this.$store.game.upgradesSlotted) {
                            Alpine.store('game').upgradesSlotted = true;
                            document.removeEventListener('mousemove', handler);
                        }
                        if (upgrade.held)
                            upgrade.pos = [e.clientX - upgrade.held[0], e.clientY - upgrade.held[1]];

                        const parentPos = this.$store.game.upgrades.find(({ id }) => id === upgrade.parent)?.pos ?? this.$store.game.ghostectorPos;
                        upgrade.inPlace = Math.hypot(upgrade.pos[0] - (parentPos[0] + upgrade.anchor[0]), upgrade.pos[1] - (parentPos[1] + upgrade.anchor[1])) < 10;
                        updateUpgradePos(this.$store.game)
                    }
                    document.addEventListener('mousemove', handler)
                },
                "@mousedown"(e) {
                    e.preventDefault();
                    if (this.$store.game.upgradesSlotted) return;
                    const rect = e.target.getBoundingClientRect();
                    this.$store.game.upgrades[this.i].held = [e.clientX - rect.left, e.clientY - rect.top];
                },
                "@mouseup"() {
                    const upgrade = this.$store.game.upgrades[this.i];
                    upgrade.held = null;
                    if (upgrade.inPlace) {
                        const pos = this.$store.game.upgrades.find(({ id }) => id === upgrade.parent)?.pos ?? this.$store.game.ghostectorPos;
                        if (upgrade.inPlace) upgrade.pos = [pos[0] + upgrade.anchor[0], pos[1] + upgrade.anchor[1]];
                    }
                },
                ":style"() {
                    const upgrade = this.$store.game.upgrades[this.i];
                    upgrade.pos ??= [0, 0];
                    return { top: `${upgrade.pos[1]}px`, left: `${upgrade.pos[0]}px`, zIndex: upgrade.inPlace && !upgrade.held ? (upgrade.z ?? 800) : 1100 };
                }
            }))
        })
    </script>
</head>

<body>
    <main x-data x-cloak>
        <div id="boss-ghost-anchor"></div>
        <div class="top-padding"></div>
        <div x-text="'$' + $store.game.money.toFixed(2)" x-show="$store.game.money" class="money-counter"></div>
        <div x-show="$store.game.boughtGhostector" class="ghostector" x-data="{
            ghostectorHeld: null,
            gtMouseDown(e) {
                e.preventDefault();
                const rect = e.target.getBoundingClientRect();
                this.ghostectorHeld = [e.clientX - rect.left, e.clientY - rect.top];
            },
            gtMove() {
                document.addEventListener('mousemove', (e) => {
                    if (this.ghostectorHeld) {
                        $store.game.ghostectorPos = [e.clientX - this.ghostectorHeld[0], e.clientY - this.ghostectorHeld[1]];
                    }
                    updateUpgradePos($store.game)
                })
            }
        }" x-init="ghostectorRender($data); gtMove()"
            :style="{ top: `${$store.game.ghostectorPos[1]}px`, left: `${$store.game.ghostectorPos[0]}px`}"
            @mousedown="gtMouseDown" @mouseup="ghostectorHeld = null">
            <canvas id="ghostector-canvas" height="192" width="192"></canvas>
            <img src="assets/ghostector.svg" height="192" width="192" />
        </div>
        <template x-for="(upgrade, i) in $store.game.upgrades">
            <div x-bind="ghostectorUpgrade" :id="upgrade.id" x-data="{ i }" x-transition:enter>
                <template x-if="upgrade.id === 'ghostector-screen'">
                    <canvas id="ghostector-screen-canvas" :height="upgrade.size[1]" :width="upgrade.size[0]"
                        x-init="gtScreenReset"
                        x-effect="if ($store.game.upgradesSlotted) { gtScreenNew(); gtScreenDraw() }"></canvas>
                </template>

                <img :src="`assets/${upgrade.id}.svg`" :height="upgrade.size[1]" :width="upgrade.size[0]"
                    @mousemove="upgrade.id === 'ghostector-screen' ? gtScreenMouseMove : () => {}"
                    @mousedown="upgrade.id === 'ghostector-screen' ? gtScreenMouseDown : () => {}"
                    @mouseup="upgrade.id === 'ghostector-screen' ? gtScreenMouseUp : () => {}">
            </div>
        </template>
        <div class="create-form">
            <label for="fake-username">Username:</label>
            <input value="25 stupid captchas" name="fake-username" disabled></input>
            <label for="fake-password">Password:</label>
            <input value="by aiden shi" name="fake-password" disabled></input>
            <button class="create-button" @click="$store.game.startGame()"
                x-text="$store.game.startedDots === 0 ? 'Create Account' : 'Creating' + '.'.repeat($store.game.startedDots)">Create
                Account</button>
        </div>
        <!-- LEVEL 1 -->
        <div class="level" x-show="$store.game.level >= 1" x-transition
            x-data="{ state: 'unchecked', grid: make4x4() }">
            <div class="error">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="icon">
                    <path fill-rule="evenodd"
                        d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-8-5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5A.75.75 0 0 1 10 5Zm0 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
                        clip-rule="evenodd" />
                </svg>
                We noticed some suspicious activity. Please complete this CAPTCHA to continue.
            </div>
            <div class="spacer"></div>
            <div class="captcha" :data-solved="$store.game.level > 1">
                <div>
                    <button class="checkbox" @click="state = state != 'open' ? 'open' : 'unchecked'" :x-state="state">
                    </button>
                    I'm not a robot
                </div>
                <div class="captcha-info"><img src="./assets/logo.png" height="32" width="32">
                    <div>CAPTCHA 1</div>
                </div>
            </div>
            <div class="captcha-model-container">
                <div x-show="state === 'open' || state === 'wrong'" x-transition.opacity class="captcha-model"
                    @click.outside="state = 'unchecked'">
                    <div class="header">
                        <div>Select all squares with</div>
                        <div>fire hydrants</div>
                        <div :style="{ opacity: grid.flat().some(Boolean) ? 0.5 : 1 }">If there are none, click skip
                        </div>
                    </div>
                    <div class="four-by-four">
                        <template x-for="(row, y) in grid">
                            <template x-for="(cell, x) in row">
                                <div class="cell" @click="row[x] = !row[x]" :class="cell && 'pressed'">
                                    <img src="./assets/fh.png"
                                        :style="{ left: `-${x * 100}%`, top: `-${(3 - y) * 100}%` }" />
                                </div>
                            </template>
                        </template>
                    </div>
                    <div x-show="state === 'wrong'" class="error try-again">Please try again.</div>

                    <hr />
                    <div class="model-bottom-bar">
                        <button x-text="grid.flat().some(Boolean) ? 'VERIFY' : 'SKIP'"
                            @click="() => { state = $store.game.solveMat(1, level1, grid); if (state === 'solved') grid = make4x4() }"></button>
                    </div>
                </div>
            </div>
        </div>
        <!-- LEVEL 2 -->
        <div class="level" x-show="$store.game.level >= 2" x-transition
            x-data="{ state: 'unchecked', grid: make4x4() }">
            <div class="error">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="icon">
                    <path fill-rule="evenodd"
                        d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-8-5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5A.75.75 0 0 1 10 5Zm0 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
                        clip-rule="evenodd" />
                </svg>
                CAPTCHA deemed too easy. Please solve another.
            </div>
            <div class="spacer"></div>
            <div class="captcha" :data-solved="$store.game.level > 2">
                <div>
                    <button class="checkbox" @click="state = state != 'open' ? 'open' : 'unchecked'" :x-state="state">
                    </button>
                    I'm not a robot
                </div>
                <div class="captcha-info"><img src="./assets/logo.png" height="32" width="32">
                    <div>CAPTCHA 2</div>
                </div>
            </div>
            <div class="captcha-model-container">
                <div x-show="state === 'open' || state === 'wrong' || state === 'objectively-wrong'"
                    x-transition.opacity class="captcha-model" @click.outside="state = 'unchecked'">
                    <div class="header">
                        <div>Select all squares with</div>
                        <div>a pipe</div>
                        <div :style="{ opacity: grid.flat().some(Boolean) ? 0.5 : 1 }">
                            If there are none, click skip
                        </div>
                    </div>
                    <div class="four-by-four">
                        <template x-for="(row, y) in grid">
                            <template x-for="(cell, x) in row">
                                <div class="cell" @click="row[x] = !row[x]" :class="cell && 'pressed'">
                                    <img src="./assets/pipe.png"
                                        :style="{ left: `-${x * 100}%`, top: `-${(3 - y) * 100}%` }" />
                                </div>
                            </template>
                        </template>
                    </div>
                    <div x-show="state === 'objectively-wrong'" class="error try-again">This is not a pipe.</div>
                    <div x-show="state === 'wrong'" class="error try-again">Please try again.</div>
                    <hr />
                    <div class="model-bottom-bar">
                        <button x-text="grid.flat().some(Boolean) ? 'VERIFY' : 'SKIP'"
                            @click="matrixMatch(level2ObjectivelyWrong, grid) ? (state = 'objectively-wrong') : (state = $store.game.solveMat(2, level2, grid))"></button>
                    </div>
                </div>
            </div>
        </div>
        <!-- LEVEL 3 -->
        <div class="level" x-show="$store.game.level >= 3" x-transition x-data="{ state: 'unchecked', answer: '' }">
            <div class="error">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="icon">
                    <path fill-rule="evenodd"
                        d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-8-5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5A.75.75 0 0 1 10 5Zm0 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
                        clip-rule="evenodd" />
                </svg>
                No boxes pressed? Must be an automated script. Please do another CAPTCHA.
            </div>
            <div class="spacer"></div>
            <div class="captcha" :data-solved="$store.game.level > 3">
                <div>
                    <button class="checkbox" @click="state = state != 'open' ? 'open' : 'unchecked'" :x-state="state">
                    </button>
                    I'm not a robot
                </div>
                <div class="captcha-info"><img src="./assets/logo.png" height="32" width="32">
                    <div>CAPTCHA 3</div>
                </div>
            </div>
            <div class="captcha-model-container">
                <div x-show="state === 'open' || state === 'wrong'" x-transition.opacity class="captcha-model"
                    @click.outside="state = 'unchecked'">
                    <div class="header">
                        <div>Solve this</div>
                        <div>SAT Question</div>
                        <div :style="{ opacity: 0.5 }">
                            Select the best answer, there is no penalty for guessing
                        </div>
                    </div>
                    <div class="multiple-choice">
                        In many cultures, a handshake can create trust between people. Engineer Jojo Avelino and his
                        team are designing a robot
                        to shake hands with a human in order to improve human-robot interactions. The robot hand adjusts
                        its movements and
                        pressure to better imitate the feel of a human hand. The researchers want the robot's handshake
                        to feel realistic
                        because ______
                        <br />
                        Which choice most logically completes the text?
                        <br />
                        <br />
                        <input type="radio" x-model="answer" value="A" id="3_A">
                        <label for="3_A">
                            A. people are less likely to interact with robots that don't look like
                            humans.
                        </label><br>
                        <input type="radio" x-model="answer" value="B" id="3_B">
                        <label for="3_B">
                            B. it's easier to program a robot to perform handshakes than it is to program a robot to
                            perform some other types of greetings.
                        </label><br>
                        <input type="radio" x-model="answer" value="C" id="3_C">
                        <label for="3_C">
                            C. the robot in the researchers' study may have uses other than interacting with humans.
                        </label><br>
                        <input type="radio" x-model="answer" value="D" id="3_D">
                        <label for="3_D">
                            D. lifelike handshakes may make people more comfortable interacting with robots.
                        </label><br>

                    </div>
                    <div x-show="state === 'wrong'" class="error try-again">Please try again.</div>
                    <hr />
                    <div class="model-bottom-bar">
                        <button :disabled="answer === ''"
                            @click="state = $store.game.solveEq(3, level3, answer)">VERIFY</button>
                    </div>
                </div>
            </div>
        </div>
        <!-- LEVEL 4 -->
        <div class="level" x-show="$store.game.level >= 4" x-transition x-data="{
                state: 'unchecked',
                wiresIn: [-1, -1, -1, -1],
                correctWiresIn: [0, 1, 2, 3],
                wireHeld: -1,
            }" x-init="shuffle(correctWiresIn)">
            <div class="error">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="icon">
                    <path fill-rule="evenodd"
                        d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-8-5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5A.75.75 0 0 1 10 5Zm0 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
                        clip-rule="evenodd" />
                </svg>
                The SAT is easy anyways. Something more rigorous is needed.
            </div>
            <div class="spacer"></div>
            <div class="captcha" :data-solved="$store.game.level > 4">
                <div>
                    <button class="checkbox"
                        @click="() => { state = state != 'open' ? 'open' : 'unchecked'; if (state === 'open') level4Sounds.open.play() }"
                        :x-state="state">
                    </button>
                    I'm not a robot
                </div>
                <div class="captcha-info"><img src="./assets/logo.png" height="32" width="32">
                    <div>CAPTCHA 4</div>
                </div>
            </div>
            <div class="captcha-model-container">
                <div x-show="state === 'open' || state === 'wrong'" x-transition.opacity class="captcha-model"
                    @click.outside="state = 'unchecked'">
                    <div class="header">
                        <div>Connect these</div>
                        <div>wires</div>
                        <div :style="{ opacity: 0.5 }">
                            Do it quick, the imposter is coming.
                        </div>
                    </div>
                    <div class="canvas">
                        <canvas id="canvas-4" x-init="level4Render($data)" width="400" height="400"
                            @mouseup="if (wireHeld != -1) {wiresIn[wireHeld] = level4Connect($event); wireHeld = -1}"
                            @mousedown="wireHeld = level4Selection($event); wiresIn[wireHeld] = -1"
                            @mousemove="level4Render($data, $event)" x-effect="if(level4CheckWin(correctWiresIn, wiresIn)) {
                                level4Sounds.solve.play();
                                setTimeout(() => {
                                    $store.game.solve(4);
                                    state = 'solved';
                                    wiresIn = [-1, -1, -1, -1];
                                    shuffle(correctWiresIn);
                                }, 500)
                            } else if (wiresIn.every(x => x != -1)) {
                                state = 'wrong'
                            }"></canvas>
                    </div>
                    <div x-show="state === 'wrong'" class="error try-again">Please try again.</div>
                </div>
            </div>
        </div>
        <!-- LEVEL 5 -->
        <div class="level" x-show="$store.game.level >= 5" x-transition
            x-data="{ state: 'unchecked', grid: make4x4(), top: 0, left: 0, moves: 0 }">
            <div class="error">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="icon">
                    <path fill-rule="evenodd"
                        d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-8-5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5A.75.75 0 0 1 10 5Zm0 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
                        clip-rule="evenodd" />
                </svg>
                Thats kinda sus. Not enough data has been collected to determine your humanness yet. Please proceed.
            </div>
            <div class="spacer"></div>
            <div class="captcha" :data-solved="$store.game.level > 5">
                <div>
                    <button class="checkbox" @click="state = state != 'open' ? 'open' : 'unchecked'" :x-state="state">
                    </button>
                    I'm not a robot
                </div>
                <div class="captcha-info"><img src="./assets/logo.png" height="32" width="32">
                    <div>CAPTCHA 5</div>
                </div>
            </div>
            <div class="captcha-model-container">
                <div x-show="state === 'open' || state === 'wrong'" x-transition.opacity class="captcha-model">
                    <div class="header">
                        <div>Select all squares with</div>
                        <div>stairs</div>
                        <div :style="{ opacity: grid.flat().some(Boolean) ? 0.5 : 1 }">If there are none, click skip
                        </div>
                    </div>
                    <div class="four-by-four">
                        <template x-for="(row, y) in grid">
                            <template x-for="(cell, x) in row">
                                <div class="cell" @click="row[x] = !row[x]" :class="cell && 'pressed'">
                                    <img src="./assets/stairs.jpeg"
                                        :style="{ left: `-${x * 100}%`, top: `-${(3 - y) * 100}%` }" />
                                </div>
                            </template>
                        </template>
                    </div>
                    <div x-show="state === 'wrong'" class="error try-again">Please try again.</div>
                    <hr />
                    <div class="model-bottom-bar">
                        <button x-text="grid.flat().some(Boolean) ? 'VERIFY' : 'SKIP'" :style="{
                                position: 'relative',
                                top: `${top}px`,
                                left: `${left}px`,
                                transition: `top ${Math.min(100 + 5 * moves, 250)}ms, left ${Math.min(100 + 5 * moves, 250)}ms`
                            }" id="jumpy-button"
                            @mouseover="setTimeout(() => {top = Math.random() * 400 - 200; left= Math.random() * 400 - 200; moves++}, 50)"
                            @click="() => { state = $store.game.solveGridCount(5, 4, grid); if (state === 'solved') { grid = make4x4(); setTimeout(() => {top = 0; left = 0;}, 100) } }"></button>
                    </div>
                </div>
            </div>
        </div>
        <!-- LEVEL 6 -->
        <div class="level" x-show="$store.game.level >= 6" x-transition
            x-data="{ state: 'unchecked', shrunk: false, inPos: false }">
            <div class="error">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="icon">
                    <path fill-rule="evenodd"
                        d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-8-5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5A.75.75 0 0 1 10 5Zm0 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
                        clip-rule="evenodd" />
                </svg>
                I couldn't vailidate whether those were actually stairs or <span style="color:transparent">not</span>.
                Please try
                again.
            </div>

            <div class="spacer"></div>
            <div class="captcha" :data-solved="$store.game.level > 6">
                <div>
                    <button class="checkbox" @click="state = inPos ? $store.game.solve(6) : 'wrong'" :x-state="state">
                    </button>
                </div>
                <div class="captcha-info"><img src="./assets/logo.png" height="32" width="32">
                    <div>CAPTCHA 6</div>
                </div>
            </div>
            <div x-sort="if ($item === 1) { shrunk = true; inPos = $position === 1 }" class="level5-switches"
                :data-collapse="$store.game.level >= 7">
                <div x-sort:item class="level5-segment1"><span x-sort:handle></span>I am</div>
                <div x-sort:item class="level5-segment3" :style="inPos ? { translate: `4rem -2.75rem` } : {}"><span
                        x-sort:handle></span> a robot</div>
                <span x-sort:item="1" class="level5-segment2"
                    :style="shrunk ? { translate: `3.7rem -2.75rem`, fontSize: '1rem' } : {}"><span
                        x-sort:handle>not</span></span>
            </div>
            <div x-show="state === 'wrong'" class="error try-again">HAH I knew you were a robot.</div>
        </div>
        <!-- LEVEL 7 -->
        <!-- Im skimping out on the floodfill but it should be somewhat fine. If i ever refine this, please implement it-->
        <div class="level" x-show="$store.game.level >= 7" x-transition
            x-data="{ state: 'unchecked', penDown: false, dontClear: false }">
            <div class="error">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="icon">
                    <path fill-rule="evenodd"
                        d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-8-5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5A.75.75 0 0 1 10 5Zm0 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
                        clip-rule="evenodd" />
                </svg>
                Okay thats it. THIS one will definitely tell if you are a robot or not.
            </div>
            <div class="spacer"></div>
            <div class="captcha" :data-solved="$store.game.level > 7">
                <div>
                    <button class="checkbox" @click="state = state != 'open' ? 'open' : 'unchecked'" :x-state="state">
                    </button>
                    I'm not a robot
                </div>
                <div class="captcha-info"><img src="./assets/logo.png" height="32" width="32">
                    <div>CAPTCHA 7</div>
                </div>
            </div>
            <div class="captcha-model-container">
                <div x-show="state === 'open' || state === 'wrong'" x-transition.opacity class="captcha-model"
                    @click.outside="state = 'unchecked'">
                    <div class="header">
                        <div>Solve this</div>
                        <div>maze</div>
                        <div :style="{ opacity: 0.5 }">
                            Draw a line from green to cyan
                        </div>
                    </div>
                    <div class="canvas">
                        <canvas id="canvas-7" x-init="level7Clear()" width="400" height="400"
                            @mouseup="() => { penDown = false; if (!dontClear) level7Clear() }"
                            @mousedown="penDown = true" @mousemove="() => {
                            if (penDown) level7Draw($event);
                            if (penDown && level7CheckWin()) dontClear = true
                        }"></canvas>
                    </div>
                    <hr />
                    <div class="model-bottom-bar">
                        <button :disabled="!dontClear" @click="() => {
                            if (dontClear) {
                                dontClear = false;
                                $store.game.solve(7);
                                state = 'solved';
                                level7Clear();
                                penDown = false
                            }
                        }">SUBMIT</button>
                    </div>
                </div>
            </div>
        </div>
        <!-- LEVEL 8 -->
        <div class="level" x-show="$store.game.level >= 8" x-transition
            x-data="{ state: 'unchecked', orderReady: false }">
            <div class="error">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="icon">
                    <path fill-rule="evenodd"
                        d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-8-5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5A.75.75 0 0 1 10 5Zm0 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
                        clip-rule="evenodd" />
                </svg>
                While you are here I might as well use you for free labor.
            </div>
            <div class="spacer"></div>
            <div class="captcha" :data-solved="$store.game.level > 8">
                <div>
                    <button class="checkbox" @click="state = state != 'open' ? 'open' : 'unchecked'" :x-state="state">
                    </button>
                    I'm not a robot
                </div>
                <div class="captcha-info"><img src="./assets/logo.png" height="32" width="32">
                    <div>CAPTCHA 8</div>
                </div>
            </div>
            <div class="captcha-model-container">
                <div x-show="state === 'open' || state === 'wrong'"
                    x-effect="if (state === 'open' || state === 'wrong') $nextTick(() => level8StartRender())"
                    x-transition.opacity class="captcha-model"
                    @click.outside="state = 'unchecked', level8State.running = false">
                    <div class="header">
                        <div>Put together a</div>
                        <div>burger</div>
                        <div :style="{ opacity: 0.5 }">
                            Make it right OK?
                        </div>
                    </div>
                    <div class="canvas">
                        <canvas id="canvas-8" width="400" height="400" @mousedown="level8MouseDown"
                            @mouseup="level8MouseUp" @mousemove="level8MouseMove"></canvas>
                    </div>
                    <div x-show="state === 'wrong'" class="error try-again">Please try again.</div>
                    <hr />
                    <div class="model-bottom-bar">
                        <button @click="level8State.stack = []"
                            :disabled="level8State.stack.length === 0">CLEAR</button>

                        <button :disabled="level8State.stack.length === 0" @click="() => {
                            state = level8Validate();
                            if (state === 'solved') {
                                $store.game.solve(8);
                                $store.game.money += 5;
                            }
                        }">FUFILL ORDER</button>
                    </div>
                </div>
            </div>
        </div>
        <!-- LEVEL 9 -->
        <div class="level" x-show="$store.game.level >= 9" x-transition
            x-data="{ state: 'unchecked', grid: make4x4() }">
            <div class="error">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="icon">
                    <path fill-rule="evenodd"
                        d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-8-5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5A.75.75 0 0 1 10 5Zm0 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
                        clip-rule="evenodd" />
                </svg>
                I have been advised to pay you for your time.
            </div>
            <div class="spacer"></div>
            <div class="captcha" :data-solved="$store.game.level > 9">
                <div>
                    <button class="checkbox" @click="state = state != 'open' ? 'open' : 'unchecked'" :x-state="state">
                    </button>
                    I'm not a robot
                </div>
                <div class="captcha-info"><img src="./assets/logo.png" height="32" width="32">
                    <div>CAPTCHA 9</div>
                </div>
            </div>
            <div class="captcha-model-container">
                <div x-show="state === 'open' || state === 'wrong'" x-transition.opacity class="captcha-model"
                    @click.outside="state = 'unchecked'">
                    <div class="header">
                        <div>Select all squares with</div>
                        <div>mines</div>
                        <div :style="{ opacity: grid.flat().some(Boolean) ? 0.5 : 1 }">If there are none, click skip
                        </div>
                    </div>
                    <div class="four-by-four">
                        <template x-for="(row, y) in grid">
                            <template x-for="(cell, x) in row">
                                <div class="cell level9-cell" @click="row[x] = !row[x]" :class="cell && 'pressed'"
                                    x-text="level9Cells[y][x] ? level9Cells[y][x] : ''" :style="{
                                        color: ['','#536ad1','#3e843e','#c84848'][level9Cells[y][x]],
                                        background: level9Cells[y][x] ? '#e0e0e0' :'#c0c0c0'
                                    }">
                                </div>
                            </template>
                        </template>
                    </div>
                    <div x-show="state === 'wrong'" class="error try-again">Please try again.</div>

                    <hr />
                    <div class="model-bottom-bar">
                        <button x-text="grid.flat().some(Boolean) ? 'VERIFY' : 'SKIP'"
                            @click="() => { state = $store.game.solveMat(9, level9, grid); if (state === 'solved') grid = make4x4() }"></button>
                    </div>
                </div>
            </div>
        </div>
        <!-- LEVEL 10 -->
        <div class="level" x-show="$store.game.level >= 10" x-transition
            x-data="{ state: 'unchecked', grid: make4x4() }">
            <div class="error">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="icon">
                    <path fill-rule="evenodd"
                        d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-8-5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5A.75.75 0 0 1 10 5Zm0 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
                        clip-rule="evenodd" />
                </svg>
                I hope you like word games.
            </div>
            <div class="spacer"></div>
            <div class="captcha" :data-solved="$store.game.level > 10">
                <div>
                    <button class="checkbox" @click="state = state != 'open' ? 'open' : 'unchecked'" :x-state="state">
                    </button>
                    I'm not a robot
                </div>
                <div class="captcha-info"><img src="./assets/logo.png" height="32" width="32">
                    <div>CAPTCHA 10</div>
                </div>
            </div>
            <div class="captcha-model-container">
                <div x-show="state === 'open' || state === 'wrong'" x-transition.opacity class="captcha-model"
                    @click.outside="state = 'unchecked'">
                    <div class="header">
                        <div>Select all squares corresponding with the</div>
                        <div>purple category</div>
                        <div :style="{ opacity:  0.5 }">Check New York Times Connections for more info.
                        </div>
                    </div>
                    <div class="four-by-four">
                        <template x-for="(row, y) in grid">
                            <template x-for="(cell, x) in row">
                                <div class="cell level10-cell" @click="row[x] = !row[x]" :class="cell && 'pressed'"
                                    x-text="level10Cells[y][x]"
                                    :style="{ fontSize: level10Cells[y][x]?.length > 9 ? '0.6rem' : '1rem' }">
                                </div>
                            </template>
                        </template>
                    </div>
                    <div x-show="state === 'wrong'" class="error try-again">Please try again.</div>

                    <hr />
                    <div class="model-bottom-bar">
                        <button x-text="grid.flat().some(Boolean) ? 'VERIFY' : 'SKIP'"
                            @click="() => { state = $store.game.solveMat(10, level10, grid); if (state === 'solved') grid = make4x4() }"></button>
                    </div>
                </div>
            </div>
        </div>
        <!-- LEVEL 11 -->
        <div class="level" x-show="$store.game.level >= 11" x-transition x-data="{ state: 'unchecked', answer: '' }">
            <div class="error">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="icon">
                    <path fill-rule="evenodd"
                        d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-8-5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5A.75.75 0 0 1 10 5Zm0 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
                        clip-rule="evenodd" />
                </svg>
                My handwriting is so bad it should be classified as a CAPTCHA.
            </div>
            <div class="spacer"></div>
            <div class="captcha" :data-solved="$store.game.level > 11">
                <div>
                    <button class="checkbox" @click="state = state != 'open' ? 'open' : 'unchecked'" :x-state="state">
                    </button>
                    I'm not a robot
                </div>
                <div class="captcha-info"><img src="./assets/logo.png" height="32" width="32">
                    <div>CAPTCHA 11</div>
                </div>
            </div>
            <div class="captcha-model-container">
                <div x-show="state === 'open' || state === 'wrong'" x-transition.opacity class="captcha-model"
                    @click.outside="state = 'unchecked'">
                    <div class="header">
                        <div>Type the characters below</div>
                        <br />
                        <img src="assets/level11.jpg" style="width:100%;" />
                    </div>
                    <div class="single-input">
                        <input x-model="answer" />
                    </div>
                    <div x-show="state === 'wrong'" class="error try-again">Please try again.</div>

                    <hr />
                    <div class="model-bottom-bar">
                        <button @click="state = $store.game.solveEq(11, level11, answer)">VERIFY</button>
                    </div>
                </div>
            </div>
        </div>
        <!-- LEVEL 12 -->
        <div class="level" x-show="$store.game.level >= 12" x-transition
            x-data="{ state: 'unchecked', grid: make4x4() }">
            <div class="error">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="icon">
                    <path fill-rule="evenodd"
                        d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-8-5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5A.75.75 0 0 1 10 5Zm0 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
                        clip-rule="evenodd" />
                </svg>
                Please ponder on this one for a bit.
            </div>
            <div class="spacer"></div>
            <div class="captcha" :data-solved="$store.game.level > 12">
                <div>
                    <button class="checkbox" @click="state = state != 'open' ? 'open' : 'unchecked'" :x-state="state">
                    </button>
                    I'm not a robot
                </div>
                <div class="captcha-info"><img src="./assets/logo.png" height="32" width="32">
                    <div>CAPTCHA 12</div>
                </div>
            </div>
            <div class="captcha-model-container">
                <div x-show="state === 'open' || state === 'wrong'" x-transition.opacity class="captcha-model"
                    @click.outside="state = 'unchecked'">
                    <div class="header">
                        <div>Select all squares with</div>
                        <div>the ship of theseus</div>
                        <div :style="{ opacity: grid.flat().some(Boolean) ? 0.5 : 1 }">If there are none, click skip
                            (every part is replaced)
                        </div>
                    </div>
                    <div class="four-by-four">
                        <template x-for="(row, y) in grid">
                            <template x-for="(cell, x) in row">
                                <div class="cell" @click="row[x] = !row[x]" :class="cell && 'pressed'">
                                    <img src="./assets/ship-of-theseus.jpg"
                                        :style="{ left: `-${x * 100}%`, top: `-${(3 - y) * 100}%` }" />
                                </div>
                            </template>
                        </template>
                    </div>
                    <div x-show="state === 'wrong'" class="error try-again">Please try again.</div>
                    <hr />
                    <div class="model-bottom-bar">
                        <button x-text="grid.flat().some(Boolean) ? 'VERIFY' : 'SKIP'"
                            @click="() => { state = eitherOr($store.game.solveMat(12, level2, grid), $store.game.solveGridCount(12, 8, grid)); if (state === 'solved') grid = make4x4() }"></button>
                    </div>
                </div>
            </div>
        </div>
        <!-- LEVEL 13 -->
        <div class="level" x-show="$store.game.level >= 13" x-transition
            x-data="{ state: 'unchecked', solve() { this.state = 'solved'; $store.game.solve(13) } }">
            <div class="error">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="icon">
                    <path fill-rule="evenodd"
                        d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-8-5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5A.75.75 0 0 1 10 5Zm0 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
                        clip-rule="evenodd" />
                </svg>
                Any self respecting human will be able to reach 10.
            </div>
            <div class="spacer"></div>
            <div class="captcha" :data-solved="$store.game.level > 13">
                <div>
                    <button class="checkbox" @click="state = state != 'open' ? 'open' : 'unchecked'" :x-state="state">
                    </button>
                    I'm not a robot
                </div>
                <div class="captcha-info"><img src="./assets/logo.png" height="32" width="32">
                    <div>CAPTCHA 13</div>
                </div>
            </div>
            <div class="captcha-model-container">
                <div x-show="state === 'open' || state === 'wrong'"
                    x-effect="if (state === 'open' || state === 'wrong') $nextTick(() => level13StartRender($data))"
                    x-transition.opacity class="captcha-model"
                    @click.outside="state = 'unchecked', level13State.running = false">
                    <div class="header">
                        <div>Get a score of at least 10 in</div>
                        <div>flappy bot</div>
                        <div :style="{ opacity: 0.5 }">
                            Click to flap
                        </div>
                    </div>
                    <div class="canvas">
                        <canvas id="canvas-13" width="400" height="400" @mousedown="level13MouseDown"></canvas>
                    </div>
                    <div x-show="state === 'wrong'" class="error try-again">Please try again.</div>
                </div>
            </div>
        </div>
        <!-- LEVEL 14 -->
        <div class="level" x-show="$store.game.level >= 14" x-transition
            x-data="{ state: 'unchecked', grid: make4x4(), attempted: false }">
            <div class="error">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="icon">
                    <path fill-rule="evenodd"
                        d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-8-5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5A.75.75 0 0 1 10 5Zm0 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
                        clip-rule="evenodd" />
                </svg>
                I don't think robots will be able to solve this one.
            </div>
            <div class="spacer"></div>
            <div class="captcha" :data-solved="$store.game.level > 14">
                <div>
                    <button class="checkbox" @click="state = state != 'open' ? 'open' : 'unchecked'" :x-state="state">
                    </button>
                    I'm not a robot
                </div>
                <div class="captcha-info"><img src="./assets/logo.png" height="32" width="32">
                    <div>CAPTCHA 14</div>
                </div>
            </div>
            <div class="captcha-model-container">
                <div x-show="state === 'open' || state === 'wrong'" x-transition.opacity class="captcha-model"
                    @click.outside="$event.target.tagName !== 'IMG' && (state = 'unchecked')">
                    <div class="header">
                        <div>Select all squares with</div>
                        <div>ghosts</div>
                        <div :style="{ opacity: grid.flat().some(Boolean) ? 0.5 : 1 }">If there are none, click skip
                        </div>
                    </div>
                    <div class="four-by-four" id="ghost-grid">
                        <template x-for="(row, y) in grid">
                            <template x-for="(cell, x) in row">
                                <div class="cell" @click="row[x] = !row[x]" :class="cell && 'pressed'">
                                    <img src="./assets/hallway-no-ghosts.jpg"
                                        :style="{ left: `-${x * 100}%`, top: `-${(3 - y) * 100}%` }" />
                                </div>
                            </template>
                        </template>
                    </div>
                    <div x-show="state === 'wrong'" class="error try-again">Please try again.</div>
                    <hr />
                    <div class="model-bottom-bar">
                        <button x-text="grid.flat().some(Boolean) ? 'VERIFY' : 'SKIP'"
                            @click="() => { state = $store.game.solveMat(14, level14, grid); if (state === 'solved') { grid = make4x4() } else if (state === 'wrong') attempted = true }"></button>
                    </div>
                </div>
                <div x-show="attempted" x-transition style="cursor: pointer;" @click="level14AdClick">
                    <img src="./assets/ad.svg">
                </div>
            </div>
        </div>
        <!-- LEVEL 15 -->
        <div class="level" x-show="$store.game.level >= 15" x-transition
            x-data="{ state: 'unchecked', grid: make4x4() }">
            <div class="error">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="icon">
                    <path fill-rule="evenodd"
                        d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-8-5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5A.75.75 0 0 1 10 5Zm0 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
                        clip-rule="evenodd" />
                </svg>
                I'm out of things to say -- but not out of CAPTCHAS!
            </div>
            <div class="spacer"></div>
            <div class="captcha" :data-solved="$store.game.level > 15">
                <div>
                    <button class="checkbox" @click="state = state != 'open' ? 'open' : 'unchecked'" :x-state="state">
                    </button>
                    I'm not a robot
                </div>
                <div class="captcha-info"><img src="./assets/logo.png" height="32" width="32">
                    <div>CAPTCHA 15</div>
                </div>
            </div>
            <div class="captcha-model-container">
                <div x-show="state === 'open' || state === 'wrong'" x-transition.opacity class="captcha-model"
                    @click.outside="state = 'unchecked'">
                    <div class="header">
                        <div>Select all squares with</div>
                        <div>objects that came first</div>
                        <div :style="{ opacity: grid.flat().some(Boolean) ? 0.5 : 1 }">If there are none, click skip
                        </div>
                    </div>
                    <div class="four-by-four" style="background-color: lightgray">
                        <template x-for="(row, y) in grid">
                            <template x-for="(cell, x) in row">
                                <div class="cell" @click="row[x] = !row[x]" :class="cell && 'pressed'">
                                    <img :src="`assets/level15/${y * 4 + x}.png`"
                                        style="height:95px;width:95px;background:white;" />
                                </div>
                            </template>
                        </template>
                    </div>
                    <div x-show="state === 'wrong'" class="error try-again">Please try again.</div>

                    <hr />
                    <div class="model-bottom-bar">
                        <button x-text="grid.flat().some(Boolean) ? 'VERIFY' : 'SKIP'"
                            @click="() => { state = $store.game.solveMat(15, level15, grid); if (state === 'solved') grid = make4x4() }"></button>
                    </div>
                </div>
            </div>
        </div>
        <!-- LEVEL 16 -->
        <div class="level" x-show="$store.game.level >= 16" x-transition x-data="{
            state: 'unchecked',
            score: [0, 0],
            current: null,
            status: '',
            reset() {
                this.score = [0, 0];
                this.current = null;
                this.status = '';
            },
            play(choice) {
                let oppChoice = null;
                if (this.current == null) oppChoice = Math.floor(Math.random() * 2);
                else oppChoice = (this.current[0] + 1) % 3;

                this.current = [choice, oppChoice];
                if (choice === oppChoice) this.status = 'Tie!'
                else if (oppChoice === (choice + 1) % 3) { this.status = 'You lose!'; this.score[1]++ }
                else { this.status = 'You win!'; this.score[0]++ }

                if (this.score[1] >= 5) {
                    this.state = 'wrong';
                    this.reset();
                }
            }
        }">
            <div class="error">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="icon">
                    <path fill-rule="evenodd"
                        d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-8-5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5A.75.75 0 0 1 10 5Zm0 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
                        clip-rule="evenodd" />
                </svg>
                Childhood classic.
            </div>
            <div class="spacer"></div>
            <div class="captcha" :data-solved="$store.game.level > 16">
                <div>
                    <button class="checkbox" @click="state = state != 'open' ? 'open' : 'unchecked'" :x-state="state">
                    </button>
                    I'm not a robot
                </div>
                <div class="captcha-info"><img src="./assets/logo.png" height="32" width="32">
                    <div>CAPTCHA 16</div>
                </div>
            </div>
            <div class="captcha-model-container">
                <div x-show="state === 'open' || state === 'wrong'" x-transition.opacity class="captcha-model"
                    @click.outside="state = 'unchecked'">
                    <div class="header">
                        <div>Beat the computer at</div>
                        <div>rock paper scissors</div>
                        <div :style="{ opacity: 0.5 }">First to 5 wins</div>
                    </div>
                    <div class="canvas">
                        <div class="rps">
                            <div class="rps-status">
                                <div x-text="score[0] + ' to ' + score[1]"></div>
                                <div
                                    x-text="current ? ['Rock','Paper','Scissors'][current[0]] + ' vs ' + ['Rock','Paper','Scissors'][current[1]] : 'Pick An Option'">
                                </div>
                                <div x-text="status || 'Nothing has been played yet'"></div>
                            </div>
                            <div class="rps-buttons">
                                <button @click="play(0)">Rock</button>
                                <button @click="play(1)">Paper</button>
                                <button @click="play(2)">Scissors</button>
                            </div>
                        </div>
                    </div>
                    <div x-show="state === 'wrong'" class="error try-again">Please try again.</div>

                    <hr />
                    <div class="model-bottom-bar">
                        <button :disabled="score[0] < 5"
                            @click="() => { if (score[0] >= 5) state = $store.game.solve(16); if (state === 'solved') reset() }">FINISH</button>
                    </div>
                </div>
            </div>
        </div>
        <!-- LEVEL 17 -->
        <div class="level" x-show="$store.game.level >= 17" x-transition
            x-data="{ state: 'unchecked', grid: make4x4() }">
            <div class="error">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="icon">
                    <path fill-rule="evenodd"
                        d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-8-5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5A.75.75 0 0 1 10 5Zm0 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
                        clip-rule="evenodd" />
                </svg>
                Yum.
            </div>
            <div class="spacer"></div>
            <div class="captcha" :data-solved="$store.game.level > 17">
                <div>
                    <button class="checkbox" @click="state = state != 'open' ? 'open' : 'unchecked'" :x-state="state">
                    </button>
                    I'm not a robot
                </div>
                <div class="captcha-info"><img src="./assets/logo.png" height="32" width="32">
                    <div>CAPTCHA 17</div>
                </div>
            </div>
            <div class="captcha-model-container">
                <div x-show="state === 'open' || state === 'wrong'" x-transition.opacity class="captcha-model"
                    @click.outside="state = 'unchecked'">
                    <div class="header">
                        <div>Select all squares that</div>
                        <div>would be hard to eat</div>
                        <div :style="{ opacity: grid.flat().some(Boolean) ? 0.5 : 1 }">If there are none, click skip
                        </div>
                    </div>
                    <div class="four-by-four" style="background-color: lightgray">
                        <template x-for="(row, y) in grid">
                            <template x-for="(cell, x) in row">
                                <div class="cell" @click="row[x] = !row[x]" :class="cell && 'pressed'">
                                    <img :src="`assets/level17/${y * 4 + x}.png`"
                                        style="height:95px;width:95px;background:white;" />
                                </div>
                            </template>
                        </template>
                    </div>
                    <div x-show="state === 'wrong'" class="error try-again">Please try again.</div>

                    <hr />
                    <div class="model-bottom-bar">
                        <button x-text="grid.flat().some(Boolean) ? 'VERIFY' : 'SKIP'"
                            @click="() => { state = $store.game.solveMat(17, level17, grid); if (state === 'solved') grid = make4x4() }"></button>
                    </div>
                </div>
            </div>
        </div>
        <!-- LEVEL 18 -->
        <div class="level" x-show="$store.game.level >= 18" x-transition
            x-data="{ state: 'unchecked', grid: chessBoard() }">
            <div class="error">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="icon">
                    <path fill-rule="evenodd"
                        d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-8-5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5A.75.75 0 0 1 10 5Zm0 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
                        clip-rule="evenodd" />
                </svg>
                I only know of one robot that can do the following, and that robot is a fish.
            </div>
            <div class="spacer"></div>
            <div class="captcha" :data-solved="$store.game.level > 18">
                <div>
                    <button class="checkbox" @click="state = state != 'open' ? 'open' : 'unchecked'" :x-state="state">
                    </button>
                    I'm not a robot
                </div>
                <div class="captcha-info"><img src="./assets/logo.png" height="32" width="32">
                    <div>CAPTCHA 18</div>
                </div>
            </div>
            <div class="captcha-model-container">
                <div x-show="state === 'open' || state === 'wrong'" x-transition.opacity class="captcha-model"
                    @click.outside="state = 'unchecked'">
                    <div class="header">
                        <div>Select all valid moves for the</div>
                        <div>white queen</div>
                        <div :style="{ opacity: grid.flat().some(Boolean) ? 0.5 : 1 }">If there are none, click skip
                        </div>
                    </div>
                    <div class="chess-board">
                        <template x-for="(row, y) in grid">
                            <template x-for="(cell, x) in row">
                                <div class="cell" @click="row[x] = !row[x]" :class="cell && 'pressed'">
                                    <img src="./assets/chess-board.png"
                                        :style="{ left: `-${x * 100}%`, top: `-${(7 - y) * 100}%` }" />
                                </div>
                            </template>
                        </template>
                    </div>
                    <div x-show="state === 'wrong'" class="error try-again">Please try again.</div>
                    <hr />
                    <div class="model-bottom-bar">
                        <button x-text="grid.flat().some(Boolean) ? 'VERIFY' : 'SKIP'"
                            @click="() => { state = $store.game.solveMat(18, level18, grid); if (state === 'solved') grid = chessBoard() }"></button>
                    </div>
                </div>
            </div>
        </div>
        <!-- LEVEL 19 -->
        <div class="level" x-show="$store.game.level >= 19" x-transition
            x-data="{ state: 'unchecked', solve() { this.state = 'solved'; $store.game.solve(19) } }">
            <div class="error">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="icon">
                    <path fill-rule="evenodd"
                        d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-8-5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5A.75.75 0 0 1 10 5Zm0 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
                        clip-rule="evenodd" />
                </svg>
                Are you over 18?
            </div>
            <div class="spacer"></div>
            <div class="captcha" :data-solved="$store.game.level > 19">
                <div>
                    <button class="checkbox" @click="state = state != 'open' ? 'open' : 'unchecked'" :x-state="state">
                    </button>
                    I'm not a robot
                </div>
                <div class="captcha-info"><img src="./assets/logo.png" height="32" width="32">
                    <div>CAPTCHA 19</div>
                </div>
            </div>
            <div class="captcha-model-container">
                <div x-show="state === 'open' || state === 'poor'"
                    x-effect="if (state === 'open' || state === 'poor') $nextTick(() => level19StartRender($data))"
                    x-transition.opacity class="captcha-model"
                    @click.outside="state = 'unchecked', level19State.running = false">
                    <div class="header">
                        <div>Win it big in this</div>
                        <div>slot machine</div>
                        <div :style="{ opacity: 0.5 }">
                            $0.50 per spin.
                        </div>
                    </div>
                    <div class="canvas">
                        <canvas id="canvas-19" width="400" height="400"></canvas>
                    </div>
                    <div x-show="state === 'poor'" class="error try-again">Too Poor! Go flip some more burgers or
                        something.</div>
                    <button class="spin-button" @click="level19Spin($data)">SPIN IT</button>
                </div>
            </div>
        </div>
        <!-- LEVEL 20 -->
        <div class="level" x-show="$store.game.level >= 20" x-transition
            x-data="{ state: 'unchecked', solve() { this.state = 'solved'; $store.game.solve(20) }, penDown: false, won: false }">
            <div class="error">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="icon">
                    <path fill-rule="evenodd"
                        d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-8-5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5A.75.75 0 0 1 10 5Zm0 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
                        clip-rule="evenodd" />
                </svg>
                More free labor yay!
            </div>
            <div class="spacer"></div>
            <div class="captcha" :data-solved="$store.game.level > 20">
                <div>
                    <button class="checkbox" @click="state = state != 'open' ? 'open' : 'unchecked'" :x-state="state">
                    </button>
                    I'm not a robot
                </div>
                <div class="captcha-info"><img src="./assets/logo.png" height="32" width="32">
                    <div>CAPTCHA 20</div>
                </div>
            </div>
            <div class="captcha-model-container">
                <div x-show="state === 'open' || state === 'wrong'" x-transition.opacity class="captcha-model"
                    @click.outside="state = 'unchecked'">
                    <div class="header">
                        <div>Clean this</div>
                        <div>dirty wall</div>
                        <div :style="{ opacity: 0.5 }">
                            (By cleaning this wall you agree to not receiving any compensation from your labor)
                        </div>
                    </div>
                    <div class="canvas">
                        <canvas id="canvas-20" width="400" height="400" x-init="level20Clear" @mouseup="penDown = false"
                            @mousedown="penDown = true" @mousemove="() => {
                                if (penDown) level20Draw($event);
                                if (penDown && level20CheckWin()) won = true
                            }"></canvas>
                    </div>
                    <hr />
                    <div class="model-bottom-bar">
                        <button :disabled="!won" @click="() => {
                            if (won) {
                                won = false;
                                $store.game.solve(20);
                                state = 'solved';
                                level20Clear();
                                penDown = false
                            }
                        }">SUBMIT</button>
                    </div>
                </div>
            </div>
        </div>
        <!-- LEVEL 21 -->
        <div class="level" x-show="$store.game.level >= 21" x-transition x-data="{ state: 'unchecked' }">
            <div class="error">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="icon">
                    <path fill-rule="evenodd"
                        d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-8-5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5A.75.75 0 0 1 10 5Zm0 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
                        clip-rule="evenodd" />
                </svg>
                Ok you know what this is getting boring, let's do some ghost busting.
            </div>
            <div class="spacer"></div>
            <div class="captcha" :data-solved="$store.game.level > 21">
                <div>
                    <button class="checkbox" @click="state = state != 'open' ? 'open' : 'unchecked'; spawnUpgrades()"
                        :x-state="state" id="upgrade-spawn">
                    </button>
                    I'm not a robot
                </div>
                <div class="captcha-info"><img src="./assets/logo.png" height="32" width="32">
                    <div>CAPTCHA 21</div>
                </div>
            </div>
            <div class="captcha-model-container">
                <div x-show="state === 'open' || state === 'wrong'" x-transition.opacity class="captcha-model"
                    x-effect="$store.game.upgradesSlotted ? (state = 'solved', $store.game.solve(21)) : null"
                    @click.outside="$event.target.tagName !== 'IMG' && (state = 'unchecked')">
                    <div class="header">
                        <div>Upgrade your</div>
                        <div>GHOSTTECTOR</div>
                        <div :style="{ opacity: 0.5 }">
                            The Ghostbusters are calling.
                        </div>
                    </div>
                    <div class="canvas">
                        <canvas width="400" height="400"></canvas>
                    </div>
                </div>
            </div>
        </div>
        <!-- LEVEL 22 -->
        <div class="level" x-show="$store.game.level >= 22" x-transition x-data="{ state: 'unchecked', progress: 0 }">
            <div class="error">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="icon">
                    <path fill-rule="evenodd"
                        d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-8-5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5A.75.75 0 0 1 10 5Zm0 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
                        clip-rule="evenodd" />
                </svg>
                Alright let's get this show on the road.
            </div>
            <div class="spacer"></div>
            <div class="captcha" :data-solved="$store.game.level > 22">
                <div>
                    <button class="checkbox" @click="state = state != 'open' ? 'open' : 'unchecked'" :x-state="state">
                    </button>
                    I'm not a robot
                </div>
                <div class="captcha-info"><img src="./assets/logo.png" height="32" width="32">
                    <div>CAPTCHA 22</div>
                </div>
            </div>
            <div class="captcha-model-container">
                <div x-show="state === 'open' || state === 'wrong'" x-transition.opacity class="captcha-model"
                    @click.outside="state = 'unchecked'">
                    <div class="header">
                        <div>Hack into the</div>
                        <div>mainframe</div>
                        <div :style="{ opacity: 0.5 }">
                            Beep boop beep boop.
                        </div>
                    </div>
                    <div class="canvas overlapped">
                        <div class="terminal" id="level22Terminal"
                            x-init="this.addEventListener('keydown', (e) => (state === 'open') && (progress += Math.floor(Math.random() * 5) + 2))">
                            <pre x-text="level22Text.substring(0, progress)"></pre>
                        </div>
                        <div class="access-granted"
                            x-show="progress && isOverflown(document.getElementById('level22Terminal'))"
                            x-transition:enter
                            x-effect="(progress && isOverflown(document.getElementById('level22Terminal'))) ? setTimeout(() => (state = 'solved', $store.game.solve(22), progress = 0),1500) : null">
                            ACCESS GRANTED</div>
                    </div>
                </div>
            </div>
        </div>
        <!-- LEVEL 23 -->
        <div class="level" x-show="$store.game.level >= 23" x-transition x-data="{ state: 'unchecked' }">
            <div class="error">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="icon">
                    <path fill-rule="evenodd"
                        d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-8-5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5A.75.75 0 0 1 10 5Zm0 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
                        clip-rule="evenodd" />
                </svg>
                TRHEAT DETECTED (drag jigsaw to fire)
            </div>
            <div class="spacer"></div>
            <div class="captcha" :data-solved="$store.game.level > 23">
                <div>
                    <button class="checkbox" @click="state = state != 'open' ? 'open' : 'unchecked'; spawnBoss()"
                        :x-state="state" id="boss-spawn">
                    </button>
                    I'm not a robot
                </div>
                <div class="captcha-info"><img src="./assets/logo.png" height="32" width="32">
                    <div>CAPTCHA 23</div>
                </div>
            </div>
            <div class="captcha-model-container">
                <div x-show="state === 'open' || state === 'wrong'" x-transition.opacity class="captcha-model"
                    @click.outside="$event.target.tagName !== 'IMG' && (state = 'unchecked')"
                    x-effect="bossGhost.hp <= 0 && (state === 'solved', $store.game.solve(23), $store.game.bossSpawned = false)">
                    <div class="header">
                        <div>Defeat the</div>
                        <div>ghost</div>
                        <div :style="{ opacity: 0.5 }">
                            Good luck soldier.
                        </div>
                    </div>
                    <div class="canvas">
                        <canvas width="400" height="400"></canvas>
                    </div>
                </div>
            </div>
        </div>
        <div class="victory-message" id="victory-message">
            <div class="dark-souls-bar">
                <div class="text">VICTORY ACHIEVED</div>
                <div class="echo" id="echo">VICTORY ACHIEVED</div>
            </div>
        </div>

        <!-- LEVEL 24 -->
        <div class="level" x-show="$store.game.level >= 24" x-transition
            x-data="{ state: 'unchecked', frustrated: false, progress: 0, opened: false }"
            x-effect="if (state === 'open' || state === 'wrong') $nextTick(() => level24Start($data))">
            <div class="error">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="icon">
                    <path fill-rule="evenodd"
                        d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-8-5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5A.75.75 0 0 1 10 5Zm0 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
                        clip-rule="evenodd" />
                </svg>
                Humans get frustrated.
            </div>
            <div class="spacer"></div>
            <div class="captcha" :data-solved="$store.game.level > 24">
                <div>
                    <button class="checkbox"
                        @click="state = state != 'open' ? 'open' : 'unchecked'; if (!opened) { frustrated = (localStorage.frustrated ? true : (localStorage.frustrated = true, false)); opened = true }"
                        :x-state="state">
                    </button>
                    I'm not a robot
                </div>
                <div class="captcha-info"><img src="./assets/logo.png" height="32" width="32">
                    <div>CAPTCHA 24</div>
                </div>
            </div>
            <div class="captcha-model-container">
                <div x-show="state === 'open' || state === 'wrong'" x-transition.opacity class="captcha-model"
                    @click.outside="state = 'unchecked', level24Running = false">
                    <div class="header">
                        <div>Show</div>
                        <div>frustration</div>
                        <div :style="{ opacity: 0.5 }" x-text="`Progress: ${(progress * 100).toFixed(2)}%`">
                            Progress - xx.xx%
                        </div>
                    </div>
                    <div class="single-input">
                        <div class="bar">
                            <div class="bar-fill" :style="{ width: `${progress * 100}%` }"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- LEVEL 25 -->
        <div class="level" x-show="$store.game.level >= 25" x-transition
            x-data="{ state: 'unchecked', message: '', msgs: [], ws: null, autoscroll: true, human: false, room: $persist('') }"
            x-effect="state === 'open' ? level25Connect($data) : null">
            <div class="error">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" class="icon">
                    <path fill-rule="evenodd"
                        d="M18 10a8 8 0 1 1-16 0 8 8 0 0 1 16 0Zm-8-5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5A.75.75 0 0 1 10 5Zm0 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2Z"
                        clip-rule="evenodd" />
                </svg>
                Alright thats it.
            </div>
            <div class="spacer"></div>
            <div class="captcha" :data-solved="$store.game.level > 25">
                <div>
                    <button class="checkbox" @click="state = state != 'open' ? 'open' : 'unchecked'" :x-state="state">
                    </button>
                    I'm not a robot
                </div>
                <div class="captcha-info"><img src="./assets/logo.png" height="32" width="32">
                    <div>CAPTCHA 25</div>
                </div>
            </div>
            <div class="captcha-model-container">
                <div x-show="state === 'open' || state === 'wrong'" x-transition.opacity class="captcha-model"
                    @click.outside="state = 'unchecked'">
                    <div class="header">
                        <div>Convince me</div>
                        <div>you are not a robot</div>
                        <div :style="{ opacity: 0.5 }">Please wait for me to respond, a
                            <span style="text-decoration: underline; cursor: pointer;"
                                @click="youveGotMail.play()">sound</span> will
                            play if the tab is open and a message is recieved. Any messages sent when the tab is closed
                            will be saved. Come back any time.
                        </div>
                    </div>
                    <div>
                        <div class="msgs" id="msgs"
                            x-effect="msgs; if (autoscroll) $nextTick(() => $el.scrollTo(0, $el.scrollHeight))">
                            <div><b>aiden</b>: <span>convince me you are human</span></div>

                            <template x-for="msg in msgs">
                                <div>
                                    <b x-text="msg.admin ? 'aiden' : 'you'"></b>: <span x-text="msg.msg"></span>
                                </div>
                            </template>
                            <div x-show="human" :style="{ opacity: 0.5 }"><em>aiden has verified your humanness</em>
                            </div>

                        </div>
                    </div>
                    <hr />
                    <div class="model-bottom-bar">
                        <input x-model="message" style="flex: 1;" placeholder="Message me">
                        <button @click="level25Send($data)">SEND</button>
                    </div>
                </div>
            </div>
        </div>
        <div class="win" x-show="$store.game.level >= 26" x-transition>
            <h1>Congrats. You are not a robot.</h1>
            <p>thanks for playing my stupid little game &lt;3</p>
            <p>more games are coming in the future :)</p>
            <br />
            <br />
            <p>with love,</p>
            <a href="https://voxal.dev"><img src="assets/aiden-shi.png"></a>
        </div>

        <div class="bottom-padding" x-show="$store.game.level >= 1 && $store.game.level <= 25"></div>
        <div class="bottom-padding" x-show="$store.game.level === 5 || $store.game.level === 23"></div>

    </main>
</body>

</html>